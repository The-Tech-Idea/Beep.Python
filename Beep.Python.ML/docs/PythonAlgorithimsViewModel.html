<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PythonAlgorithimsViewModel - Beep.Python.ML</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link href="assets/styles.css" rel="stylesheet">
</head>
<body>
    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" onclick="toggleSidebar()">
        <i class="bi bi-list"></i>
    </button>

    <!-- Theme Toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <i class="bi bi-sun-fill" id="theme-icon"></i>
    </button>

    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <!-- Navigation will be loaded dynamically -->
        </aside>

        <!-- Main Content -->
        <main class="content">
            <div class="content-wrapper">
                <!-- Page Header -->
                <div class="page-header">
                    <div class="header-content">
                        <h1><i class="bi bi-cpu text-warning"></i> PythonAlgorithimsViewModel</h1>
                        <p class="lead">MVVM ViewModel for machine learning algorithm selection, configuration, and management with intelligent recommendations supporting .NET 6, 7, 8, and 9</p>
                        
                        <div class="achievement-badges">
                            <span class="badge bg-success"><i class="bi bi-check-circle"></i> 25+ Algorithms</span>
                            <span class="badge bg-info"><i class="bi bi-brain"></i> Smart Selection</span>
                            <span class="badge bg-warning"><i class="bi bi-gear"></i> Auto Configuration</span>
                            <span class="badge bg-primary"><i class="bi bi-star"></i> MVVM Ready</span>
                        </div>
                    </div>
                </div>

                <!-- Class Overview -->
                <section class="section" id="class-overview">
                    <h2>?? Class Overview</h2>
                    <p>PythonAlgorithimsViewModel provides comprehensive MVVM support for machine learning algorithm selection, configuration, and management. It offers intelligent algorithm recommendations, automatic parameter configuration, and seamless integration with the ML training pipeline.</p>
                    
                    <div class="code-example">
                        <h4>Class Declaration and Architecture</h4>
                        <pre><code class="language-csharp">public partial class PythonAlgorithimsViewModel : PythonBaseViewModel
{
    // Observable properties for algorithm management
    [ObservableProperty] private ObservableCollection&lt;AlgorithmInfo&gt; availableAlgorithms;
    [ObservableProperty] private AlgorithmInfo selectedAlgorithm;
    [ObservableProperty] private ObservableCollection&lt;AlgorithmCategory&gt; algorithmCategories;
    [ObservableProperty] private string selectedCategory;
    
    // Algorithm configuration
    [ObservableProperty] private ObservableCollection&lt;ParameterInfo&gt; algorithmParameters;
    [ObservableProperty] private Dictionary&lt;string, object&gt; currentParameterValues;
    [ObservableProperty] private bool isParameterConfigurationValid;
    
    // Algorithm recommendations
    [ObservableProperty] private ObservableCollection&lt;AlgorithmRecommendation&gt; recommendations;
    [ObservableProperty] private bool isAnalyzingDataForRecommendations;
    [ObservableProperty] private DataCharacteristics dataCharacteristics;
    
    // Performance and comparison
    [ObservableProperty] private ObservableCollection&lt;AlgorithmPerformance&gt; performanceComparison;
    [ObservableProperty] private ObservableCollection&lt;AlgorithmBenchmark&gt; benchmarkResults;
    
    // Search and filtering
    [ObservableProperty] private string algorithmSearchText;
    [ObservableProperty] private ObservableCollection&lt;AlgorithmInfo&gt; filteredAlgorithms;
    [ObservableProperty] private AlgorithmFilterOptions filterOptions;
    
    // Commands for algorithm operations
    public IAsyncRelayCommand AnalyzeDataCommand { get; }
    public IAsyncRelayCommand GetRecommendationsCommand { get; }
    public IRelayCommand SelectAlgorithmCommand { get; }
    public IAsyncRelayCommand ConfigureParametersCommand { get; }
    public IAsyncRelayCommand CompareAlgorithmsCommand { get; }
    public IAsyncRelayCommand BenchmarkAlgorithmsCommand { get; }
    public IRelayCommand ResetParametersCommand { get; }
}</code></pre>
                    </div>
                </section>

                <!-- Algorithm Categories -->
                <section class="section" id="algorithm-categories">
                    <h2>?? Algorithm Categories</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-tags"></i> Comprehensive Algorithm Classification</h3>
                        
                        <div class="code-example">
                            <h4>Algorithm Category Management</h4>
                            <pre><code class="language-csharp">public void InitializeAlgorithmCategories()
{
    AlgorithmCategories.Clear();
    
    // Classification Algorithms
    AlgorithmCategories.Add(new AlgorithmCategory
    {
        Name = "Classification",
        Description = "Algorithms for predicting discrete class labels",
        Icon = "??",
        Algorithms = new[]
        {
            MachineLearningAlgorithm.LogisticRegression,
            MachineLearningAlgorithm.RandomForestClassifier,
            MachineLearningAlgorithm.GradientBoostingClassifier,
            MachineLearningAlgorithm.SVC,
            MachineLearningAlgorithm.KNeighborsClassifier,
            MachineLearningAlgorithm.DecisionTreeClassifier,
            MachineLearningAlgorithm.NaiveBayes,
            MachineLearningAlgorithm.AdaBoostClassifier,
            MachineLearningAlgorithm.ExtraTreesClassifier
        }
    });
    
    // Regression Algorithms
    AlgorithmCategories.Add(new AlgorithmCategory
    {
        Name = "Regression",
        Description = "Algorithms for predicting continuous numerical values",
        Icon = "??",
        Algorithms = new[]
        {
            MachineLearningAlgorithm.LinearRegression,
            MachineLearningAlgorithm.RandomForestRegressor,
            MachineLearningAlgorithm.GradientBoostingRegressor,
            MachineLearningAlgorithm.SVR,
            MachineLearningAlgorithm.KNeighborsRegressor,
            MachineLearningAlgorithm.DecisionTreeRegressor,
            MachineLearningAlgorithm.AdaBoostRegressor,
            MachineLearningAlgorithm.ExtraTreesRegressor
        }
    });
    
    // Clustering Algorithms
    AlgorithmCategories.Add(new AlgorithmCategory
    {
        Name = "Clustering",
        Description = "Algorithms for grouping similar data points",
        Icon = "??",
        Algorithms = new[]
        {
            MachineLearningAlgorithm.KMeans,
            MachineLearningAlgorithm.DBSCAN,
            MachineLearningAlgorithm.AgglomerativeClustering,
            MachineLearningAlgorithm.SpectralClustering
        }
    });
    
    // Ensemble Methods
    AlgorithmCategories.Add(new AlgorithmCategory
    {
        Name = "Ensemble",
        Description = "Meta-algorithms combining multiple base algorithms",
        Icon = "???",
        Algorithms = new[]
        {
            MachineLearningAlgorithm.VotingClassifier,
            MachineLearningAlgorithm.VotingRegressor,
            MachineLearningAlgorithm.BaggingClassifier,
            MachineLearningAlgorithm.BaggingRegressor,
            MachineLearningAlgorithm.StackingClassifier,
            MachineLearningAlgorithm.StackingRegressor
        }
    });
    
    // Deep Learning (Neural Networks)
    AlgorithmCategories.Add(new AlgorithmCategory
    {
        Name = "Neural Networks",
        Description = "Deep learning and neural network algorithms",
        Icon = "??",
        Algorithms = new[]
        {
            MachineLearningAlgorithm.MLPClassifier,
            MachineLearningAlgorithm.MLPRegressor
        }
    });
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <h3><i class="bi bi-info-circle"></i> Algorithm Information System</h3>
                        
                        <div class="code-example">
                            <h4>Detailed Algorithm Metadata</h4>
                            <pre><code class="language-csharp">public class AlgorithmInfo
{
    public MachineLearningAlgorithm Algorithm { get; set; }
    public string Name { get; set; }
    public string DisplayName { get; set; }
    public string Description { get; set; }
    public string Category { get; set; }
    public AlgorithmType Type { get; set; }
    public AlgorithmComplexity Complexity { get; set; }
    public TimeComplexity TrainingTimeComplexity { get; set; }
    public TimeComplexity PredictionTimeComplexity { get; set; }
    public string[] Strengths { get; set; }
    public string[] Weaknesses { get; set; }
    public string[] UseCases { get; set; }
    public ParameterInfo[] DefaultParameters { get; set; }
    public string[] RequiredPackages { get; set; }
    public bool SupportsMulticlass { get; set; }
    public bool SupportsProbabilityEstimates { get; set; }
    public bool HandlesImbalancedData { get; set; }
    public bool RequiresFeatureScaling { get; set; }
    public int MinimumSampleSize { get; set; }
    public string Icon { get; set; }
    public string Color { get; set; }
}

private AlgorithmInfo CreateAlgorithmInfo(MachineLearningAlgorithm algorithm)
{
    return algorithm switch
    {
        MachineLearningAlgorithm.RandomForestClassifier => new AlgorithmInfo
        {
            Algorithm = algorithm,
            Name = "Random Forest Classifier",
            DisplayName = "?? Random Forest",
            Description = "Ensemble method using multiple decision trees with majority voting",
            Category = "Classification",
            Type = AlgorithmType.Supervised,
            Complexity = AlgorithmComplexity.Medium,
            TrainingTimeComplexity = TimeComplexity.OLogN,
            PredictionTimeComplexity = TimeComplexity.OLogN,
            Strengths = new[] 
            { 
                "Handles overfitting well", 
                "Works with mixed data types", 
                "Provides feature importance",
                "Robust to outliers"
            },
            Weaknesses = new[] 
            { 
                "Can overfit with very noisy data", 
                "Less interpretable than single trees",
                "Memory intensive for large datasets"
            },
            UseCases = new[] 
            { 
                "General classification tasks", 
                "Feature selection", 
                "Imbalanced datasets",
                "When interpretability is needed"
            },
            DefaultParameters = GetDefaultParameters(algorithm),
            RequiredPackages = new[] { "scikit-learn" },
            SupportsMulticlass = true,
            SupportsProbabilityEstimates = true,
            HandlesImbalancedData = true,
            RequiresFeatureScaling = false,
            MinimumSampleSize = 100,
            Icon = "??",
            Color = "#28a745"
        },
        
        MachineLearningAlgorithm.LogisticRegression => new AlgorithmInfo
        {
            Algorithm = algorithm,
            Name = "Logistic Regression",
            DisplayName = "?? Logistic Regression",
            Description = "Linear model for binary and multiclass classification using logistic function",
            Category = "Classification",
            Type = AlgorithmType.Supervised,
            Complexity = AlgorithmComplexity.Low,
            TrainingTimeComplexity = TimeComplexity.ON,
            PredictionTimeComplexity = TimeComplexity.O1,
            Strengths = new[] 
            { 
                "Fast training and prediction", 
                "Highly interpretable", 
                "Probabilistic output",
                "No hyperparameter tuning required"
            },
            Weaknesses = new[] 
            { 
                "Assumes linear relationship", 
                "Sensitive to outliers",
                "Requires feature scaling"
            },
            UseCases = new[] 
            { 
                "Binary classification", 
                "Baseline model", 
                "When interpretability is crucial",
                "Large datasets with linear patterns"
            },
            DefaultParameters = GetDefaultParameters(algorithm),
            RequiredPackages = new[] { "scikit-learn" },
            SupportsMulticlass = true,
            SupportsProbabilityEstimates = true,
            HandlesImbalancedData = false,
            RequiresFeatureScaling = true,
            MinimumSampleSize = 50,
            Icon = "??",
            Color = "#007bff"
        },
        
        MachineLearningAlgorithm.SVC => new AlgorithmInfo
        {
            Algorithm = algorithm,
            Name = "Support Vector Classifier",
            DisplayName = "? SVM",
            Description = "Support Vector Machine for classification using kernel methods",
            Category = "Classification",
            Type = AlgorithmType.Supervised,
            Complexity = AlgorithmComplexity.High,
            TrainingTimeComplexity = TimeComplexity.ON2,
            PredictionTimeComplexity = TimeComplexity.ON,
            Strengths = new[] 
            { 
                "Effective in high dimensions", 
                "Memory efficient", 
                "Versatile with different kernels",
                "Works well with small datasets"
            },
            Weaknesses = new[] 
            { 
                "Slow on large datasets", 
                "Sensitive to feature scaling",
                "No probabilistic output by default"
            },
            UseCases = new[] 
            { 
                "High-dimensional data", 
                "Text classification", 
                "Image classification",
                "Small to medium datasets"
            },
            DefaultParameters = GetDefaultParameters(algorithm),
            RequiredPackages = new[] { "scikit-learn" },
            SupportsMulticlass = true,
            SupportsProbabilityEstimates = false,
            HandlesImbalancedData = false,
            RequiresFeatureScaling = true,
            MinimumSampleSize = 100,
            Icon = "?",
            Color = "#ffc107"
        }
        // ... Additional algorithms
    };
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Smart Algorithm Recommendations -->
                <section class="section" id="smart-recommendations">
                    <h2>?? Smart Algorithm Recommendations</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-magic"></i> Intelligent Algorithm Selection</h3>
                        
                        <div class="code-example">
                            <h4>Data-Driven Algorithm Recommendations</h4>
                            <pre><code class="language-csharp">// Analyze data characteristics and provide algorithm recommendations
private async Task GetRecommendationsAsync()
{
    try
    {
        IsAnalyzingDataForRecommendations = true;
        
        // Analyze data characteristics
        var dataAnalysis = await AnalyzeDataCharacteristics();
        DataCharacteristics = dataAnalysis;
        
        // Generate recommendations based on data analysis
        var recommendations = GenerateAlgorithmRecommendations(dataAnalysis);
        
        Recommendations.Clear();
        foreach (var recommendation in recommendations.OrderByDescending(r => r.Score))
        {
            Recommendations.Add(recommendation);
        }
        
        ShowSuccessMessage($"Generated {recommendations.Count} algorithm recommendations");
    }
    catch (Exception ex)
    {
        ShowErrorMessage($"Failed to generate recommendations: {ex.Message}");
    }
    finally
    {
        IsAnalyzingDataForRecommendations = false;
    }
}

private async Task&lt;DataCharacteristics&gt; AnalyzeDataCharacteristics()
{
    if (MLManager == null) throw new InvalidOperationException("ML Manager not initialized");
    
    // Get basic data information
    var dataInfo = await MLManager.GetDataInfo();
    
    return new DataCharacteristics
    {
        SampleCount = dataInfo.RowCount,
        FeatureCount = dataInfo.ColumnCount,
        HasMissingValues = dataInfo.HasMissingValues,
        HasCategoricalFeatures = dataInfo.HasCategoricalFeatures,
        HasNumericalFeatures = dataInfo.HasNumericalFeatures,
        HasTextFeatures = dataInfo.HasTextFeatures,
        IsImbalanced = await CheckDataImbalance(),
        HasHighDimensionality = dataInfo.ColumnCount > 1000,
        HasLargeDataset = dataInfo.RowCount > 100000,
        HasNonLinearPatterns = await DetectNonLinearPatterns(),
        NoiseLevel = await EstimateNoiseLevel(),
        DatasetSize = GetDatasetSizeCategory(dataInfo.RowCount),
        ProblemType = DetermineProblemType(dataInfo)
    };
}

private List&lt;AlgorithmRecommendation&gt; GenerateAlgorithmRecommendations(DataCharacteristics data)
{
    var recommendations = new List&lt;AlgorithmRecommendation&gt;();
    
    foreach (var algorithmInfo in AvailableAlgorithms)
    {
        var score = CalculateAlgorithmScore(algorithmInfo, data);
        var reasoning = GenerateRecommendationReasoning(algorithmInfo, data, score);
        
        recommendations.Add(new AlgorithmRecommendation
        {
            Algorithm = algorithmInfo,
            Score = score,
            Confidence = CalculateConfidence(score, data),
            Reasoning = reasoning,
            EstimatedTrainingTime = EstimateTrainingTime(algorithmInfo, data),
            EstimatedAccuracy = EstimateAccuracy(algorithmInfo, data),
            Pros = GetAlgorithmPros(algorithmInfo, data),
            Cons = GetAlgorithmCons(algorithmInfo, data),
            RecommendationType = GetRecommendationType(score)
        });
    }
    
    return recommendations;
}

private double CalculateAlgorithmScore(AlgorithmInfo algorithm, DataCharacteristics data)
{
    double score = 0.5; // Base score
    
    // Dataset size considerations
    if (data.HasLargeDataset)
    {
        if (algorithm.TrainingTimeComplexity == TimeComplexity.ON || 
            algorithm.TrainingTimeComplexity == TimeComplexity.OLogN)
        {
            score += 0.2; // Bonus for scalable algorithms
        }
        else if (algorithm.TrainingTimeComplexity == TimeComplexity.ON2)
        {
            score -= 0.3; // Penalty for slow algorithms
        }
    }
    
    // Feature scaling requirements
    if (data.HasMixedFeatureScales && algorithm.RequiresFeatureScaling)
    {
        score -= 0.1; // Small penalty for requiring preprocessing
    }
    
    // Imbalanced data handling
    if (data.IsImbalanced && algorithm.HandlesImbalancedData)
    {
        score += 0.15; // Bonus for handling imbalanced data well
    }
    
    // High dimensionality
    if (data.HasHighDimensionality)
    {
        if (algorithm.Algorithm == MachineLearningAlgorithm.SVC ||
            algorithm.Algorithm == MachineLearningAlgorithm.LogisticRegression)
        {
            score += 0.1; // These work well with high dimensions
        }
        else if (algorithm.Algorithm == MachineLearningAlgorithm.KNeighborsClassifier)
        {
            score -= 0.2; // KNN struggles with high dimensions
        }
    }
    
    // Non-linear patterns
    if (data.HasNonLinearPatterns)
    {
        if (algorithm.Algorithm == MachineLearningAlgorithm.RandomForestClassifier ||
            algorithm.Algorithm == MachineLearningAlgorithm.GradientBoostingClassifier ||
            algorithm.Algorithm == MachineLearningAlgorithm.SVC)
        {
            score += 0.2; // These handle non-linearity well
        }
        else if (algorithm.Algorithm == MachineLearningAlgorithm.LogisticRegression ||
                 algorithm.Algorithm == MachineLearningAlgorithm.LinearRegression)
        {
            score -= 0.15; // Linear models struggle with non-linearity
        }
    }
    
    // Noise level considerations
    if (data.NoiseLevel > 0.3) // High noise
    {
        if (algorithm.Algorithm == MachineLearningAlgorithm.RandomForestClassifier)
        {
            score += 0.1; // Random Forest is robust to noise
        }
        else if (algorithm.Algorithm == MachineLearningAlgorithm.KNeighborsClassifier)
        {
            score -= 0.1; // KNN is sensitive to noise
        }
    }
    
    return Math.Max(0, Math.Min(1, score)); // Clamp between 0 and 1
}

public class AlgorithmRecommendation
{
    public AlgorithmInfo Algorithm { get; set; }
    public double Score { get; set; }
    public double Confidence { get; set; }
    public string Reasoning { get; set; }
    public TimeSpan EstimatedTrainingTime { get; set; }
    public double EstimatedAccuracy { get; set; }
    public string[] Pros { get; set; }
    public string[] Cons { get; set; }
    public RecommendationType RecommendationType { get; set; }
    public string ScoreDescription => Score switch
    {
        >= 0.8 => "Excellent Match",
        >= 0.7 => "Very Good Match", 
        >= 0.6 => "Good Match",
        >= 0.5 => "Fair Match",
        _ => "Poor Match"
    };
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Parameter Configuration -->
                <section class="section" id="parameter-configuration">
                    <h2>?? Intelligent Parameter Configuration</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-sliders"></i> Dynamic Parameter Management</h3>
                        
                        <div class="code-example">
                            <h4>Adaptive Parameter Configuration</h4>
                            <pre><code class="language-csharp">// Configure algorithm parameters based on data characteristics
private async Task ConfigureParametersAsync()
{
    try
    {
        if (SelectedAlgorithm == null) return;
        
        // Get parameter definitions for selected algorithm
        var parameterDefs = GetParameterDefinitions(SelectedAlgorithm.Algorithm);
        
        // Apply intelligent defaults based on data characteristics
        var optimizedParams = ApplyIntelligentDefaults(parameterDefs, DataCharacteristics);
        
        // Update observable collections
        AlgorithmParameters.Clear();
        CurrentParameterValues.Clear();
        
        foreach (var param in optimizedParams)
        {
            AlgorithmParameters.Add(param);
            CurrentParameterValues[param.Name] = param.OptimizedValue ?? param.DefaultValue;
        }
        
        // Validate parameter configuration
        IsParameterConfigurationValid = ValidateParameterConfiguration();
        
        ShowInformationMessage($"Configured {optimizedParams.Count} parameters for {SelectedAlgorithm.DisplayName}");
    }
    catch (Exception ex)
    {
        ShowErrorMessage($"Parameter configuration failed: {ex.Message}");
    }
}

private List&lt;ParameterInfo&gt; ApplyIntelligentDefaults(List&lt;ParameterInfo&gt; parameters, DataCharacteristics data)
{
    var optimizedParams = new List&lt;ParameterInfo&gt;();
    
    foreach (var param in parameters)
    {
        var optimizedParam = param.Clone();
        
        // Apply data-driven optimizations
        switch (param.Name.ToLower())
        {
            case "n_estimators":
                // More estimators for larger datasets, but consider training time
                if (data.HasLargeDataset)
                {
                    optimizedParam.OptimizedValue = Math.Min(200, (int)param.DefaultValue * 2);
                    optimizedParam.Reasoning = "Increased for large dataset but limited for training time";
                }
                else if (data.SampleCount < 1000)
                {
                    optimizedParam.OptimizedValue = Math.Max(50, (int)param.DefaultValue / 2);
                    optimizedParam.Reasoning = "Reduced for small dataset to prevent overfitting";
                }
                break;
                
            case "max_depth":
                // Adjust tree depth based on dataset size and complexity
                if (data.HasLargeDataset && data.HasNonLinearPatterns)
                {
                    optimizedParam.OptimizedValue = Math.Min(20, ((int?)param.DefaultValue ?? 10) + 5);
                    optimizedParam.Reasoning = "Increased depth for complex patterns in large dataset";
                }
                else if (data.SampleCount < 1000)
                {
                    optimizedParam.OptimizedValue = Math.Max(3, ((int?)param.DefaultValue ?? 10) - 3);
                    optimizedParam.Reasoning = "Reduced depth to prevent overfitting on small dataset";
                }
                break;
                
            case "c": // SVM regularization
                if (data.HasHighDimensionality)
                {
                    optimizedParam.OptimizedValue = 0.1; // Stronger regularization
                    optimizedParam.Reasoning = "Stronger regularization for high-dimensional data";
                }
                else if (data.NoiseLevel > 0.3)
                {
                    optimizedParam.OptimizedValue = 10.0; // Weaker regularization
                    optimizedParam.Reasoning = "Weaker regularization to handle noisy data";
                }
                break;
                
            case "kernel": // SVM kernel
                if (data.HasNonLinearPatterns)
                {
                    optimizedParam.OptimizedValue = "rbf";
                    optimizedParam.Reasoning = "RBF kernel recommended for non-linear patterns";
                }
                else
                {
                    optimizedParam.OptimizedValue = "linear";
                    optimizedParam.Reasoning = "Linear kernel for linear patterns and faster training";
                }
                break;
                
            case "n_neighbors": // KNN
                // Use sqrt(n) as a good starting point
                var optimalK = Math.Max(3, (int)Math.Sqrt(data.SampleCount));
                if (optimalK % 2 == 0) optimalK++; // Ensure odd number
                optimizedParam.OptimizedValue = Math.Min(optimalK, 15);
                optimizedParam.Reasoning = $"Optimized based on dataset size (sqrt({data.SampleCount}))";
                break;
                
            case "learning_rate":
                if (data.HasLargeDataset)
                {
                    optimizedParam.OptimizedValue = 0.01; // Smaller learning rate for large datasets
                    optimizedParam.Reasoning = "Smaller learning rate for stable training on large dataset";
                }
                else
                {
                    optimizedParam.OptimizedValue = 0.1; // Default or slightly higher
                    optimizedParam.Reasoning = "Standard learning rate for moderate dataset size";
                }
                break;
                
            case "class_weight":
                if (data.IsImbalanced)
                {
                    optimizedParam.OptimizedValue = "balanced";
                    optimizedParam.Reasoning = "Balanced class weights to handle imbalanced data";
                }
                break;
        }
        
        optimizedParams.Add(optimizedParam);
    }
    
    return optimizedParams;
}

public class ParameterInfo
{
    public string Name { get; set; }
    public string DisplayName { get; set; }
    public string Description { get; set; }
    public Type ParameterType { get; set; }
    public object DefaultValue { get; set; }
    public object OptimizedValue { get; set; }
    public object MinValue { get; set; }
    public object MaxValue { get; set; }
    public object[] AllowedValues { get; set; }
    public string Reasoning { get; set; }
    public bool IsRequired { get; set; }
    public bool IsAdvanced { get; set; }
    public string Category { get; set; }
    public string ValidationRule { get; set; }
    
    public ParameterInfo Clone()
    {
        return new ParameterInfo
        {
            Name = this.Name,
            DisplayName = this.DisplayName,
            Description = this.Description,
            ParameterType = this.ParameterType,
            DefaultValue = this.DefaultValue,
            OptimizedValue = this.OptimizedValue,
            MinValue = this.MinValue,
            MaxValue = this.MaxValue,
            AllowedValues = this.AllowedValues?.Clone() as object[],
            Reasoning = this.Reasoning,
            IsRequired = this.IsRequired,
            IsAdvanced = this.IsAdvanced,
            Category = this.Category,
            ValidationRule = this.ValidationRule
        };
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Algorithm Comparison -->
                <section class="section" id="algorithm-comparison">
                    <h2>?? Algorithm Comparison and Benchmarking</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-bar-chart-steps"></i> Performance Comparison</h3>
                        
                        <div class="code-example">
                            <h4>Multi-Algorithm Benchmarking</h4>
                            <pre><code class="language-csharp">// Compare multiple algorithms on the current dataset
private async Task CompareAlgorithmsAsync()
{
    try
    {
        var algorithmsToCompare = Recommendations.Take(5).Select(r => r.Algorithm).ToList();
        
        PerformanceComparison.Clear();
        
        foreach (var algorithm in algorithmsToCompare)
        {
            var performance = await BenchmarkAlgorithm(algorithm);
            PerformanceComparison.Add(performance);
        }
        
        // Sort by performance score
        var sortedPerformance = PerformanceComparison.OrderByDescending(p => p.OverallScore).ToList();
        PerformanceComparison.Clear();
        foreach (var perf in sortedPerformance)
        {
            PerformanceComparison.Add(perf);
        }
        
        ShowSuccessMessage($"Compared {algorithmsToCompare.Count} algorithms successfully");
    }
    catch (Exception ex)
    {
        ShowErrorMessage($"Algorithm comparison failed: {ex.Message}");
    }
}

private async Task&lt;AlgorithmPerformance&gt; BenchmarkAlgorithm(AlgorithmInfo algorithm)
{
    var stopwatch = Stopwatch.StartNew();
    
    try
    {
        // Configure algorithm with optimal parameters
        var parameters = GetOptimalParameters(algorithm, DataCharacteristics);
        
        // Train model with cross-validation
        var cvResult = await MLManager.PerformCrossValidation(
            algorithm.Algorithm,
            parameters,
            cvFolds: 5,
            scoringMetric: "f1_weighted");
        
        stopwatch.Stop();
        
        return new AlgorithmPerformance
        {
            Algorithm = algorithm,
            Accuracy = cvResult.MeanScore,
            StandardDeviation = cvResult.StdScore,
            TrainingTime = stopwatch.Elapsed,
            MemoryUsage = GC.GetTotalMemory(false) / (1024 * 1024), // MB
            OverallScore = CalculateOverallScore(cvResult.MeanScore, stopwatch.Elapsed),
            CrossValidationScores = cvResult.Scores?.ToArray() ?? new double[0],
            ParametersUsed = parameters,
            BenchmarkTimestamp = DateTime.Now
        };
    }
    catch (Exception ex)
    {
        stopwatch.Stop();
        
        return new AlgorithmPerformance
        {
            Algorithm = algorithm,
            Accuracy = 0,
            StandardDeviation = 0,
            TrainingTime = stopwatch.Elapsed,
            MemoryUsage = 0,
            OverallScore = 0,
            ErrorMessage = ex.Message,
            BenchmarkTimestamp = DateTime.Now
        };
    }
}

public class AlgorithmPerformance
{
    public AlgorithmInfo Algorithm { get; set; }
    public double Accuracy { get; set; }
    public double StandardDeviation { get; set; }
    public TimeSpan TrainingTime { get; set; }
    public double MemoryUsage { get; set; } // MB
    public double OverallScore { get; set; }
    public double[] CrossValidationScores { get; set; }
    public Dictionary&lt;string, object&gt; ParametersUsed { get; set; }
    public DateTime BenchmarkTimestamp { get; set; }
    public string ErrorMessage { get; set; }
    public bool HasError => !string.IsNullOrEmpty(ErrorMessage);
    
    public string PerformanceGrade => OverallScore switch
    {
        >= 0.9 => "A+",
        >= 0.8 => "A",
        >= 0.7 => "B",
        >= 0.6 => "C",
        >= 0.5 => "D",
        _ => "F"
    };
    
    public string TrainingTimeDescription => TrainingTime.TotalSeconds switch
    {
        < 1 => "Very Fast",
        < 10 => "Fast",
        < 60 => "Moderate",
        < 300 => "Slow",
        _ => "Very Slow"
    };
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- UI Integration -->
                <section class="section" id="ui-integration">
                    <h2>?? UI Integration Examples</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-window"></i> Complete Algorithm Selection UI</h3>
                        
                        <div class="code-example">
                            <h4>WPF Algorithm Management Interface</h4>
                            <pre><code class="language-xml">&lt;!-- Algorithm Selection and Configuration UI --&gt;
&lt;TabControl Margin="10"&gt;
    &lt;!-- Algorithm Categories Tab --&gt;
    &lt;TabItem Header="?? Categories"&gt;
        &lt;Grid&gt;
            &lt;Grid.ColumnDefinitions&gt;
                &lt;ColumnDefinition Width="200"/&gt;
                &lt;ColumnDefinition Width="*"/&gt;
            &lt;/Grid.ColumnDefinitions&gt;
            
            &lt;!-- Category List --&gt;
            &lt;ListBox Grid.Column="0" ItemsSource="{Binding AlgorithmCategories}"
                     SelectedValue="{Binding SelectedCategory}"
                     SelectedValuePath="Name"&gt;
                &lt;ListBox.ItemTemplate&gt;
                    &lt;DataTemplate&gt;
                        &lt;StackPanel Orientation="Horizontal"&gt;
                            &lt;TextBlock Text="{Binding Icon}" FontSize="16" Margin="0,0,5,0"/&gt;
                            &lt;TextBlock Text="{Binding Name}" FontWeight="Bold"/&gt;
                        &lt;/StackPanel&gt;
                    &lt;/DataTemplate&gt;
                &lt;/ListBox.ItemTemplate&gt;
            &lt;/ListBox&gt;
            
            &lt;!-- Algorithm List --&gt;
            &lt;DataGrid Grid.Column="1" ItemsSource="{Binding FilteredAlgorithms}"
                      SelectedItem="{Binding SelectedAlgorithm}"
                      AutoGenerateColumns="False" Margin="10"&gt;
                &lt;DataGrid.Columns&gt;
                    &lt;DataGridTemplateColumn Header="Algorithm" Width="250"&gt;
                        &lt;DataGridTemplateColumn.CellTemplate&gt;
                            &lt;DataTemplate&gt;
                                &lt;StackPanel Orientation="Horizontal"&gt;
                                    &lt;TextBlock Text="{Binding Icon}" FontSize="16" Margin="0,0,5,0"/&gt;
                                    &lt;TextBlock Text="{Binding DisplayName}" FontWeight="Bold"/&gt;
                                &lt;/StackPanel&gt;
                            &lt;/DataTemplate&gt;
                        &lt;/DataGridTemplateColumn.CellTemplate&gt;
                    &lt;/DataGridTemplateColumn&gt;
                    &lt;DataGridTextColumn Header="Complexity" Binding="{Binding Complexity}" Width="100"/&gt;
                    &lt;DataGridTextColumn Header="Time Complexity" Binding="{Binding TrainingTimeComplexity}" Width="120"/&gt;
                    &lt;DataGridTemplateColumn Header="Features" Width="200"&gt;
                        &lt;DataGridTemplateColumn.CellTemplate&gt;
                            &lt;DataTemplate&gt;
                                &lt;StackPanel&gt;
                                    &lt;TextBlock Text="? Multiclass" Visibility="{Binding SupportsMulticlass, Converter={StaticResource BooleanToVisibilityConverter}}" FontSize="10"/&gt;
                                    &lt;TextBlock Text="? Probabilities" Visibility="{Binding SupportsProbabilityEstimates, Converter={StaticResource BooleanToVisibilityConverter}}" FontSize="10"/&gt;
                                    &lt;TextBlock Text="? Imbalanced" Visibility="{Binding HandlesImbalancedData, Converter={StaticResource BooleanToVisibilityConverter}}" FontSize="10"/&gt;
                                &lt;/StackPanel&gt;
                            &lt;/DataTemplate&gt;
                        &lt;/DataGridTemplateColumn.CellTemplate&gt;
                    &lt;/DataGridTemplateColumn&gt;
                &lt;/DataGrid.Columns&gt;
            &lt;/DataGrid&gt;
        &lt;/Grid&gt;
    &lt;/TabItem&gt;
    
    &lt;!-- Recommendations Tab --&gt;
    &lt;TabItem Header="?? Recommendations"&gt;
        &lt;Grid&gt;
            &lt;Grid.RowDefinitions&gt;
                &lt;RowDefinition Height="Auto"/&gt;
                &lt;RowDefinition Height="*"/&gt;
            &lt;/Grid.RowDefinitions&gt;
            
            &lt;Button Grid.Row="0" Content="?? Get Smart Recommendations" 
                    Command="{Binding GetRecommendationsCommand}"
                    IsEnabled="{Binding IsAnalyzingDataForRecommendations, Converter={StaticResource InverseBooleanConverter}}"
                    Style="{StaticResource PrimaryButtonStyle}" Margin="10"/&gt;
            
            &lt;DataGrid Grid.Row="1" ItemsSource="{Binding Recommendations}"
                      AutoGenerateColumns="False" Margin="10"&gt;
                &lt;DataGrid.Columns&gt;
                    &lt;DataGridTextColumn Header="Rank" Binding="{Binding Rank}" Width="50"/&gt;
                    &lt;DataGridTemplateColumn Header="Algorithm" Width="200"&gt;
                        &lt;DataGridTemplateColumn.CellTemplate&gt;
                            &lt;DataTemplate&gt;
                                &lt;StackPanel Orientation="Horizontal"&gt;
                                    &lt;TextBlock Text="{Binding Algorithm.Icon}" FontSize="16" Margin="0,0,5,0"/&gt;
                                    &lt;TextBlock Text="{Binding Algorithm.DisplayName}"/&gt;
                                &lt;/StackPanel&gt;
                            &lt;/DataTemplate&gt;
                        &lt;/DataGridTemplateColumn.CellTemplate&gt;
                    &lt;/DataGridTemplateColumn&gt;
                    &lt;DataGridTemplateColumn Header="Score" Width="100"&gt;
                        &lt;DataGridTemplateColumn.CellTemplate&gt;
                            &lt;DataTemplate&gt;
                                &lt;StackPanel&gt;
                                    &lt;ProgressBar Value="{Binding Score}" Maximum="1" Height="15"
                                                 Background="LightGray" Foreground="Green"/&gt;
                                    &lt;TextBlock Text="{Binding ScoreDescription}" FontSize="10" HorizontalAlignment="Center"/&gt;
                                &lt;/StackPanel&gt;
                            &lt;/DataTemplate&gt;
                        &lt;/DataGridTemplateColumn.CellTemplate&gt;
                    &lt;/DataGridTemplateColumn&gt;
                    &lt;DataGridTextColumn Header="Est. Time" Binding="{Binding EstimatedTrainingTime, StringFormat=mm\\:ss}" Width="80"/&gt;
                    &lt;DataGridTextColumn Header="Est. Accuracy" Binding="{Binding EstimatedAccuracy, StringFormat=P1}" Width="100"/&gt;
                    &lt;DataGridTextColumn Header="Reasoning" Binding="{Binding Reasoning}" Width="300"/&gt;
                &lt;/DataGrid.Columns&gt;
            &lt;/DataGrid&gt;
        &lt;/Grid&gt;
    &lt;/TabItem&gt;
    
    &lt;!-- Parameter Configuration Tab --&gt;
    &lt;TabItem Header="?? Parameters"&gt;
        &lt;Grid&gt;
            &lt;Grid.RowDefinitions&gt;
                &lt;RowDefinition Height="Auto"/&gt;
                &lt;RowDefinition Height="*"/&gt;
                &lt;RowDefinition Height="Auto"/&gt;
            &lt;/Grid.RowDefinitions&gt;
            
            &lt;TextBlock Grid.Row="0" Text="{Binding SelectedAlgorithm.DisplayName, StringFormat='Configuring: {0}'}" 
                       FontSize="16" FontWeight="Bold" Margin="10"/&gt;
            
            &lt;ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto"&gt;
                &lt;ItemsControl ItemsSource="{Binding AlgorithmParameters}" Margin="10"&gt;
                    &lt;ItemsControl.ItemTemplate&gt;
                        &lt;DataTemplate&gt;
                            &lt;Border BorderBrush="LightGray" BorderThickness="1" Margin="5" Padding="10"&gt;
                                &lt;Grid&gt;
                                    &lt;Grid.ColumnDefinitions&gt;
                                        &lt;ColumnDefinition Width="150"/&gt;
                                        &lt;ColumnDefinition Width="200"/&gt;
                                        &lt;ColumnDefinition Width="*"/&gt;
                                    &lt;/Grid.ColumnDefinitions&gt;
                                    
                                    &lt;TextBlock Grid.Column="0" Text="{Binding DisplayName}" FontWeight="Bold" VerticalAlignment="Center"/&gt;
                                    
                                    &lt;TextBox Grid.Column="1" Text="{Binding OptimizedValue}" 
                                             VerticalAlignment="Center" Margin="5"/&gt;
                                    
                                    &lt;StackPanel Grid.Column="2"&gt;
                                        &lt;TextBlock Text="{Binding Description}" FontSize="11" Foreground="Gray"/&gt;
                                        &lt;TextBlock Text="{Binding Reasoning}" FontSize="10" Foreground="Blue" FontStyle="Italic"/&gt;
                                    &lt;/StackPanel&gt;
                                &lt;/Grid&gt;
                            &lt;/Border&gt;
                        &lt;/DataTemplate&gt;
                    &lt;/ItemsControl.ItemTemplate&gt;
                &lt;/ItemsControl&gt;
            &lt;/ScrollViewer&gt;
            
            &lt;StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center" Margin="10"&gt;
                &lt;Button Content="?? Auto-Configure" 
                        Command="{Binding ConfigureParametersCommand}"
                        Style="{StaticResource InfoButtonStyle}"/&gt;
                &lt;Button Content="?? Reset to Defaults" 
                        Command="{Binding ResetParametersCommand}"
                        Style="{StaticResource WarningButtonStyle}"/&gt;
            &lt;/StackPanel&gt;
        &lt;/Grid&gt;
    &lt;/TabItem&gt;
    
    &lt;!-- Performance Comparison Tab --&gt;
    &lt;TabItem Header="?? Comparison"&gt;
        &lt;Grid&gt;
            &lt;Grid.RowDefinitions&gt;
                &lt;RowDefinition Height="Auto"/&gt;
                &lt;RowDefinition Height="*"/&gt;
            &lt;/Grid.RowDefinitions&gt;
            
            &lt;Button Grid.Row="0" Content="?? Benchmark Algorithms" 
                    Command="{Binding CompareAlgorithmsCommand}"
                    Style="{StaticResource SuccessButtonStyle}" Margin="10"/&gt;
            
            &lt;DataGrid Grid.Row="1" ItemsSource="{Binding PerformanceComparison}"
                      AutoGenerateColumns="False" Margin="10"&gt;
                &lt;DataGrid.Columns&gt;
                    &lt;DataGridTextColumn Header="Rank" Binding="{Binding Rank}" Width="50"/&gt;
                    &lt;DataGridTemplateColumn Header="Algorithm" Width="200"&gt;
                        &lt;DataGridTemplateColumn.CellTemplate&gt;
                            &lt;DataTemplate&gt;
                                &lt;StackPanel Orientation="Horizontal"&gt;
                                    &lt;TextBlock Text="{Binding Algorithm.Icon}" FontSize="16" Margin="0,0,5,0"/&gt;
                                    &lt;TextBlock Text="{Binding Algorithm.DisplayName}"/&gt;
                                &lt;/StackPanel&gt;
                            &lt;/DataTemplate&gt;
                        &lt;/DataGridTemplateColumn.CellTemplate&gt;
                    &lt;/DataGridTemplateColumn&gt;
                    &lt;DataGridTextColumn Header="Accuracy" Binding="{Binding Accuracy, StringFormat=P2}" Width="80"/&gt;
                    &lt;DataGridTextColumn Header="Std Dev" Binding="{Binding StandardDeviation, StringFormat=F4}" Width="80"/&gt;
                    &lt;DataGridTextColumn Header="Time" Binding="{Binding TrainingTimeDescription}" Width="100"/&gt;
                    &lt;DataGridTextColumn Header="Grade" Binding="{Binding PerformanceGrade}" Width="60"/&gt;
                    &lt;DataGridTemplateColumn Header="Overall Score" Width="120"&gt;
                        &lt;DataGridTemplateColumn.CellTemplate&gt;
                            &lt;DataTemplate&gt;
                                &lt;ProgressBar Value="{Binding OverallScore}" Maximum="1" Height="15"
                                             Background="LightGray" Foreground="Blue"/&gt;
                            &lt;/DataTemplate&gt;
                        &lt;/DataGridTemplateColumn.CellTemplate&gt;
                    &lt;/DataGridTemplateColumn&gt;
                &lt;/DataGrid.Columns&gt;
            &lt;/DataGrid&gt;
        &lt;/Grid&gt;
    &lt;/TabItem&gt;
&lt;/TabControl&gt;</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Navigation Links -->
                <div class="nav-links">
                    <a href="PythonTrainingViewModel.html" class="btn-beep">
                        <i class="bi bi-laptop"></i> Training ViewModel
                    </a>
                    <a href="ModelEvaluationGraphsViewModel.html" class="btn-beep">
                        <i class="bi bi-graph-up"></i> Evaluation ViewModel
                    </a>
                    <a href="algorithm-management.html" class="btn-beep">
                        <i class="bi bi-cpu"></i> Algorithm Management
                    </a>
                </div>

                <!-- Footer -->
                <footer class="documentation-footer">
                    <div class="footer-content">
                        <div class="footer-copyright">
                            <p>&copy; 2024 The Tech Idea - Beep.Python.ML PythonAlgorithimsViewModel Documentation</p>
                            <p>Intelligent Algorithm Selection and Management for .NET 6, 7, 8, and 9</p>
                        </div>
                        <div class="footer-links">
                            <a href="#class-overview">Class Overview</a>
                            <a href="#algorithm-categories">Categories</a>
                            <a href="#smart-recommendations">Smart Recommendations</a>
                            <a href="#parameter-configuration">Parameter Configuration</a>
                        </div>
                    </div>
                </footer>
            </div>
        </main>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="assets/navigation.js"></script>
</body>
</html>