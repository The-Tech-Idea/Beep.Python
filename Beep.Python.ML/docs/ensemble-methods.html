<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ensemble Methods - Beep.Python.ML</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link href="assets/styles.css" rel="stylesheet">
</head>
<body>
    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" onclick="toggleSidebar()">
        <i class="bi bi-list"></i>
    </button>

    <!-- Theme Toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <i class="bi bi-sun-fill" id="theme-icon"></i>
    </button>

    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <!-- Navigation will be loaded dynamically -->
        </aside>

        <!-- Main Content -->
        <main class="content">
            <div class="content-wrapper">
                <!-- Page Header -->
                <div class="page-header">
                    <div class="header-content">
                        <h1><i class="bi bi-layers text-warning"></i> Ensemble Methods</h1>
                        <p class="lead">Advanced ensemble learning techniques for combining multiple models to achieve superior performance in .NET 6, 7, 8, and 9</p>
                        
                        <div class="achievement-badges">
                            <span class="badge bg-success"><i class="bi bi-check-circle"></i> Voting Classifiers</span>
                            <span class="badge bg-info"><i class="bi bi-stack"></i> Stacking</span>
                            <span class="badge bg-warning"><i class="bi bi-bootstrap"></i> Bagging</span>
                            <span class="badge bg-primary"><i class="bi bi-star"></i> Boosting</span>
                        </div>
                    </div>
                </div>

                <!-- Ensemble Overview -->
                <section class="section" id="ensemble-overview">
                    <h2>?? Ensemble Methods Overview</h2>
                    <p>Ensemble methods combine multiple machine learning models to create a stronger predictor than any individual model alone. Beep.Python.ML provides comprehensive ensemble learning capabilities through the TrainingExtensions and advanced ViewModel integration.</p>
                    
                    <div class="row">
                        <div class="col-md-6">
                            <div class="feature-card">
                                <h4><i class="bi bi-vote-fill text-primary"></i> Voting Methods</h4>
                                <ul>
                                    <li><strong>Hard Voting:</strong> Majority class prediction</li>
                                    <li><strong>Soft Voting:</strong> Average of class probabilities</li>
                                    <li><strong>Weighted Voting:</strong> Performance-weighted predictions</li>
                                    <li><strong>Dynamic Voting:</strong> Context-aware weighting</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="col-md-6">
                            <div class="feature-card">
                                <h4><i class="bi bi-layers text-success"></i> Meta-Learning Methods</h4>
                                <ul>
                                    <li><strong>Stacking:</strong> Meta-learner combines predictions</li>
                                    <li><strong>Blending:</strong> Holdout set validation</li>
                                    <li><strong>Multi-Level Stacking:</strong> Hierarchical ensembles</li>
                                    <li><strong>Cross-Validation Stacking:</strong> Robust meta-features</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Voting Ensembles -->
                <section class="section" id="voting-ensembles">
                    <h2>??? Voting Ensembles</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-check2-all"></i> Basic Voting Classifier</h3>
                        
                        <div class="code-example">
                            <h4>Simple Voting Ensemble</h4>
                            <pre><code class="language-csharp">// Create voting ensemble using TrainingExtensions
var baseAlgorithms = new[]
{
    MachineLearningAlgorithm.RandomForestClassifier,
    MachineLearningAlgorithm.GradientBoostingClassifier,
    MachineLearningAlgorithm.LogisticRegression,
    MachineLearningAlgorithm.SVC
};

// Execute ensemble training
var ensembleResult = await viewModel.TrainEnsembleAsync(
    EnsembleType.Voting,
    baseAlgorithms);

if (ensembleResult.Success)
{
    Console.WriteLine($"?? Voting Ensemble Results:");
    Console.WriteLine($"Ensemble Score: {ensembleResult.EnsembleScore:F4}");
    Console.WriteLine($"Individual Scores: {string.Join(", ", ensembleResult.BaseModelScores.Select(s => s.ToString("F4")))}");
    Console.WriteLine($"Improvement: {(ensembleResult.EnsembleScore - ensembleResult.BaseModelScores.Max()):+F4}");
}</code></pre>
                        </div>

                        <div class="code-example">
                            <h4>Advanced Voting Configuration</h4>
                            <pre><code class="language-csharp">// Advanced voting ensemble with custom weights and parameters
public class VotingEnsembleConfiguration
{
    public VotingType VotingType { get; set; } = VotingType.Soft;
    public Dictionary&lt;MachineLearningAlgorithm, double&gt; ModelWeights { get; set; }
    public Dictionary&lt;MachineLearningAlgorithm, Dictionary&lt;string, object&gt;&gt; ModelParameters { get; set; }
    public bool UsePerformanceWeighting { get; set; } = true;
    public string WeightingMetric { get; set; } = "f1_weighted";
}

public async Task&lt;EnsembleResult&gt; CreateAdvancedVotingEnsemble()
{
    var config = new VotingEnsembleConfiguration
    {
        VotingType = VotingType.Soft,
        UsePerformanceWeighting = true,
        WeightingMetric = "f1_weighted",
        ModelWeights = new Dictionary&lt;MachineLearningAlgorithm, double&gt;
        {
            [MachineLearningAlgorithm.RandomForestClassifier] = 1.0,
            [MachineLearningAlgorithm.GradientBoostingClassifier] = 1.2,  // Higher weight
            [MachineLearningAlgorithm.LogisticRegression] = 0.8,
            [MachineLearningAlgorithm.SVC] = 1.0
        },
        ModelParameters = new Dictionary&lt;MachineLearningAlgorithm, Dictionary&lt;string, object&gt;&gt;
        {
            [MachineLearningAlgorithm.RandomForestClassifier] = new Dictionary&lt;string, object&gt;
            {
                ["n_estimators"] = 200,
                ["max_depth"] = 15,
                ["random_state"] = 42
            },
            [MachineLearningAlgorithm.GradientBoostingClassifier] = new Dictionary&lt;string, object&gt;
            {
                ["n_estimators"] = 150,
                ["learning_rate"] = 0.1,
                ["random_state"] = 42
            }
        }
    };

    // Train individual models first
    var baseModels = new List&lt;(MachineLearningAlgorithm Algorithm, string ModelId, double Score)&gt;();
    
    foreach (var algorithm in config.ModelWeights.Keys)
    {
        var modelId = $"ensemble_base_{algorithm}";
        var parameters = config.ModelParameters.GetValueOrDefault(algorithm, new Dictionary&lt;string, object&gt;());
        
        // Train base model
        PythonMLManager.TrainModel(modelId, algorithm, parameters, Features, LabelColumn);
        
        // Evaluate performance
        var scores = PythonMLManager.GetModelClassificationScore(modelId);
        var score = config.WeightingMetric switch
        {
            "accuracy" => scores.Item1,
            "f1_weighted" => scores.Item2,
            _ => scores.Item1
        };
        
        baseModels.Add((algorithm, modelId, score));
        Console.WriteLine($"Base model {algorithm}: {score:F4}");
    }

    // Create weighted voting ensemble
    var result = await CreateWeightedVotingEnsemble(baseModels, config);
    return result;
}</code></pre>
                        </div>
                    </div>

                    <div class="tip">
                        <h5><i class="bi bi-lightbulb"></i> Voting Ensemble Best Practices</h5>
                        <ul>
                            <li><strong>Diversity:</strong> Use algorithms with different learning paradigms</li>
                            <li><strong>Soft Voting:</strong> Generally performs better than hard voting</li>
                            <li><strong>Performance Weighting:</strong> Weight models by validation performance</li>
                            <li><strong>Calibration:</strong> Ensure probability estimates are well-calibrated</li>
                            <li><strong>Odd Numbers:</strong> Use odd number of models to avoid ties</li>
                        </ul>
                    </div>
                </section>

                <!-- Stacking Ensembles -->
                <section class="section" id="stacking-ensembles">
                    <h2>?? Stacking Ensembles</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-stack"></i> Meta-Learning with Stacking</h3>
                        
                        <div class="code-example">
                            <h4>Basic Stacking Implementation</h4>
                            <pre><code class="language-csharp">// Stacking ensemble with meta-learner
public class StackingEnsembleConfiguration
{
    public MachineLearningAlgorithm[] BaseModels { get; set; }
    public MachineLearningAlgorithm MetaLearner { get; set; } = MachineLearningAlgorithm.LogisticRegression;
    public int CVFolds { get; set; } = 5;
    public bool UseMultiLevel { get; set; } = false;
    public string StackingStrategy { get; set; } = "cv_predictions";
}

public async Task&lt;EnsembleResult&gt; CreateStackingEnsemble()
{
    var config = new StackingEnsembleConfiguration
    {
        BaseModels = new[]
        {
            MachineLearningAlgorithm.RandomForestClassifier,
            MachineLearningAlgorithm.GradientBoostingClassifier,
            MachineLearningAlgorithm.SVC,
            MachineLearningAlgorithm.KNeighborsClassifier
        },
        MetaLearner = MachineLearningAlgorithm.LogisticRegression,
        CVFolds = 5,
        StackingStrategy = "cv_predictions"
    };

    Console.WriteLine("??? Building stacking ensemble...");
    
    // Phase 1: Train base models with cross-validation
    var baseModelPredictions = new Dictionary&lt;string, double[]&gt;();
    
    foreach (var algorithm in config.BaseModels)
    {
        Console.WriteLine($"Training base model: {algorithm}");
        
        var modelId = $"stacking_base_{algorithm}";
        var cvPredictions = await TrainBaseModelWithCrossValidation(
            modelId, algorithm, config.CVFolds);
        
        baseModelPredictions[modelId] = cvPredictions;
    }
    
    // Phase 2: Create meta-features from base model predictions
    var metaFeatures = CreateMetaFeatures(baseModelPredictions);
    
    // Phase 3: Train meta-learner
    Console.WriteLine($"Training meta-learner: {config.MetaLearner}");
    var metaModelId = "stacking_meta_learner";
    
    var metaParameters = new Dictionary&lt;string, object&gt;
    {
        ["C"] = 1.0,
        ["max_iter"] = 1000,
        ["random_state"] = 42
    };
    
    PythonMLManager.TrainModelWithFeatures(
        metaModelId, 
        config.MetaLearner, 
        metaParameters, 
        metaFeatures, 
        LabelColumn);
    
    // Phase 4: Evaluate stacking ensemble
    var stackingScore = await EvaluateStackingEnsemble(baseModelPredictions, metaModelId);
    
    var result = new EnsembleResult
    {
        Success = true,
        EnsembleType = EnsembleType.Stacking,
        EnsembleScore = stackingScore,
        BaseModelScores = baseModelPredictions.Values.Select(GetModelScore).ToArray(),
        EstimatorCount = config.BaseModels.Length + 1, // Base models + meta-learner
        TrainingTime = DateTime.Now - startTime,
        Algorithms = config.BaseModels.Select(a => a.ToString()).ToArray()
    };
    
    Console.WriteLine($"?? Stacking ensemble completed!");
    Console.WriteLine($"Final ensemble score: {result.EnsembleScore:F4}");
    
    return result;
}

private async Task&lt;double[]&gt; TrainBaseModelWithCrossValidation(
    string modelId, 
    MachineLearningAlgorithm algorithm, 
    int cvFolds)
{
    // Implement cross-validation predictions for stacking
    var predictions = new double[DataSize]; // Placeholder
    
    // Use cross-validation to generate out-of-fold predictions
    for (int fold = 0; fold < cvFolds; fold++)
    {
        var foldModelId = $"{modelId}_fold_{fold}";
        
        // Train on fold data (implementation would use actual CV splitting)
        var parameters = GetDefaultParameters(algorithm);
        PythonMLManager.TrainModel(foldModelId, algorithm, parameters, Features, LabelColumn);
        
        // Get predictions for validation fold
        var foldPredictions = PythonMLManager.Predict(foldModelId, ValidationFeatures);
        
        // Store out-of-fold predictions
        // (implementation would properly map to correct indices)
    }
    
    return predictions;
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <h3><i class="bi bi-layers"></i> Multi-Level Stacking</h3>
                        
                        <div class="code-example">
                            <h4>Advanced Multi-Level Stacking</h4>
                            <pre><code class="language-csharp">// Multi-level stacking with hierarchical meta-learners
public class MultiLevelStackingConfiguration
{
    public List&lt;MachineLearningAlgorithm[]&gt; StackingLevels { get; set; }
    public MachineLearningAlgorithm[] MetaLearners { get; set; }
    public string BlendingStrategy { get; set; } = "weighted_average";
}

public async Task&lt;EnsembleResult&gt; CreateMultiLevelStackingEnsemble()
{
    var config = new MultiLevelStackingConfiguration
    {
        StackingLevels = new List&lt;MachineLearningAlgorithm[]&gt;
        {
            // Level 1: Diverse base models
            new[]
            {
                MachineLearningAlgorithm.RandomForestClassifier,
                MachineLearningAlgorithm.GradientBoostingClassifier,
                MachineLearningAlgorithm.SVC,
                MachineLearningAlgorithm.KNeighborsClassifier,
                MachineLearningAlgorithm.NaiveBayes
            },
            // Level 2: Intermediate meta-learners
            new[]
            {
                MachineLearningAlgorithm.LogisticRegression,
                MachineLearningAlgorithm.RandomForestClassifier
            }
        },
        MetaLearners = new[]
        {
            MachineLearningAlgorithm.LogisticRegression, // Level 1 meta-learner
            MachineLearningAlgorithm.GradientBoostingClassifier // Final meta-learner
        }
    };

    Console.WriteLine("??? Building multi-level stacking ensemble...");
    
    var levelPredictions = new List&lt;Dictionary&lt;string, double[]&gt;&gt;();
    
    // Train each stacking level
    for (int level = 0; level < config.StackingLevels.Count; level++)
    {
        Console.WriteLine($"Training stacking level {level + 1}...");
        
        var levelModels = config.StackingLevels[level];
        var currentLevelPredictions = new Dictionary&lt;string, double[]&gt;();
        
        foreach (var algorithm in levelModels)
        {
            var modelId = $"multilevel_L{level}_{algorithm}";
            
            // Use predictions from previous level as features (if not first level)
            var inputFeatures = level == 0 ? Features : CombineFeatures(Features, levelPredictions[level - 1]);
            
            var cvPredictions = await TrainBaseModelWithCrossValidation(modelId, algorithm, 5);
            currentLevelPredictions[modelId] = cvPredictions;
        }
        
        levelPredictions.Add(currentLevelPredictions);
        
        // Train meta-learner for this level
        if (level < config.MetaLearners.Length)
        {
            var metaModelId = $"multilevel_meta_L{level}";
            var metaFeatures = CreateMetaFeatures(currentLevelPredictions);
            
            PythonMLManager.TrainModelWithFeatures(
                metaModelId,
                config.MetaLearners[level],
                GetDefaultParameters(config.MetaLearners[level]),
                metaFeatures,
                LabelColumn);
        }
    }
    
    // Final evaluation
    var finalScore = await EvaluateMultiLevelEnsemble(levelPredictions);
    
    var result = new EnsembleResult
    {
        Success = true,
        EnsembleType = EnsembleType.MultiLevelStacking,
        EnsembleScore = finalScore,
        EstimatorCount = config.StackingLevels.Sum(level => level.Length) + config.MetaLearners.Length,
        TrainingTime = DateTime.Now - startTime
    };
    
    Console.WriteLine($"?? Multi-level stacking completed! Final score: {result.EnsembleScore:F4}");
    return result;
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Bagging and Boosting -->
                <section class="section" id="bagging-boosting">
                    <h2>?? Bagging and Boosting</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-bootstrap"></i> Bootstrap Aggregation (Bagging)</h3>
                        
                        <div class="code-example">
                            <h4>Custom Bagging Implementation</h4>
                            <pre><code class="language-csharp">// Custom bagging ensemble
public class BaggingEnsembleConfiguration
{
    public MachineLearningAlgorithm BaseEstimator { get; set; } = MachineLearningAlgorithm.DecisionTreeClassifier;
    public int NumberOfEstimators { get; set; } = 10;
    public double SampleRate { get; set; } = 1.0; // Bootstrap sample size
    public double FeatureSampleRate { get; set; } = 1.0; // Feature subsampling
    public bool ReplaceFeatures { get; set; } = false;
    public bool ReplaceSamples { get; set; } = true;
    public int RandomState { get; set; } = 42;
}

public async Task&lt;EnsembleResult&gt; CreateBaggingEnsemble()
{
    var config = new BaggingEnsembleConfiguration
    {
        BaseEstimator = MachineLearningAlgorithm.DecisionTreeClassifier,
        NumberOfEstimators = 50,
        SampleRate = 0.8,
        FeatureSampleRate = 0.8,
        RandomState = 42
    };

    Console.WriteLine("?? Creating bagging ensemble...");
    
    var baggingModels = new List&lt;(string ModelId, double Weight)&gt;();
    var random = new Random(config.RandomState);
    
    for (int i = 0; i < config.NumberOfEstimators; i++)
    {
        Console.WriteLine($"Training bagging estimator {i + 1}/{config.NumberOfEstimators}");
        
        // Create bootstrap sample
        var bootstrapSample = CreateBootstrapSample(config.SampleRate, random);
        var featureSubset = CreateFeatureSubset(config.FeatureSampleRate, random);
        
        // Train base estimator on bootstrap sample
        var modelId = $"bagging_estimator_{i}";
        var parameters = new Dictionary&lt;string, object&gt;
        {
            ["max_depth"] = random.Next(5, 15),
            ["min_samples_split"] = random.Next(2, 10),
            ["random_state"] = random.Next()
        };
        
        PythonMLManager.TrainModelWithSubset(
            modelId,
            config.BaseEstimator,
            parameters,
            featureSubset,
            LabelColumn,
            bootstrapSample);
        
        // Evaluate individual estimator
        var scores = PythonMLManager.GetModelClassificationScore(modelId);
        baggingModels.Add((modelId, 1.0 / config.NumberOfEstimators)); // Equal weighting
    }
    
    // Combine predictions from all bagging estimators
    var ensembleScore = await EvaluateBaggingEnsemble(baggingModels);
    
    var result = new EnsembleResult
    {
        Success = true,
        EnsembleType = EnsembleType.Bagging,
        EnsembleScore = ensembleScore,
        EstimatorCount = config.NumberOfEstimators,
        TrainingTime = DateTime.Now - startTime,
        BaseModelScores = baggingModels.Select(m => GetModelPerformance(m.ModelId)).ToArray()
    };
    
    Console.WriteLine($"?? Bagging ensemble completed! Score: {result.EnsembleScore:F4}");
    return result;
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <h3><i class="bi bi-speedometer2"></i> Gradient Boosting Ensembles</h3>
                        
                        <div class="code-example">
                            <h4>Custom Boosting Implementation</h4>
                            <pre><code class="language-csharp">// Sequential boosting with adaptive weighting
public class AdaptiveBoostingConfiguration
{
    public MachineLearningAlgorithm BaseEstimator { get; set; } = MachineLearningAlgorithm.DecisionTreeClassifier;
    public int NumberOfEstimators { get; set; } = 50;
    public double LearningRate { get; set; } = 1.0;
    public string BoostingType { get; set; } = "SAMME"; // or "SAMME.R"
    public int MaxDepth { get; set; } = 1; // Stumps for AdaBoost
}

public async Task&lt;EnsembleResult&gt; CreateBoostingEnsemble()
{
    var config = new AdaptiveBoostingConfiguration
    {
        NumberOfEstimators = 100,
        LearningRate = 0.1,
        MaxDepth = 3
    };

    Console.WriteLine("? Creating adaptive boosting ensemble...");
    
    var boostingModels = new List&lt;(string ModelId, double Weight, double Error)&gt;();
    var sampleWeights = InitializeUniformWeights(DataSize);
    
    for (int iteration = 0; iteration < config.NumberOfEstimators; iteration++)
    {
        Console.WriteLine($"Boosting iteration {iteration + 1}/{config.NumberOfEstimators}");
        
        // Train weak learner on weighted samples
        var modelId = $"boosting_estimator_{iteration}";
        var parameters = new Dictionary&lt;string, object&gt;
        {
            ["max_depth"] = config.MaxDepth,
            ["random_state"] = iteration
        };
        
        PythonMLManager.TrainModelWithWeights(
            modelId,
            config.BaseEstimator,
            parameters,
            Features,
            LabelColumn,
            sampleWeights);
        
        // Calculate weighted error
        var predictions = PythonMLManager.Predict(modelId, Features);
        var weightedError = CalculateWeightedError(predictions, TrueLabels, sampleWeights);
        
        // Calculate model weight (AdaBoost formula)
        var modelWeight = config.LearningRate * Math.Log((1 - weightedError) / Math.Max(weightedError, 1e-10));
        
        boostingModels.Add((modelId, modelWeight, weightedError));
        
        // Update sample weights
        sampleWeights = UpdateSampleWeights(sampleWeights, predictions, TrueLabels, modelWeight);
        
        // Early stopping if perfect classification
        if (weightedError < 1e-10)
        {
            Console.WriteLine($"Perfect classification achieved at iteration {iteration + 1}");
            break;
        }
        
        // Progress reporting
        if (iteration % 10 == 0)
        {
            var currentScore = await EvaluateBoostingEnsemble(boostingModels.Take(iteration + 1));
            Console.WriteLine($"Iteration {iteration + 1}: Weighted Error = {weightedError:F4}, Current Score = {currentScore:F4}");
        }
    }
    
    // Final ensemble evaluation
    var finalScore = await EvaluateBoostingEnsemble(boostingModels);
    
    var result = new EnsembleResult
    {
        Success = true,
        EnsembleType = EnsembleType.AdaptiveBoosting,
        EnsembleScore = finalScore,
        EstimatorCount = boostingModels.Count,
        TrainingTime = DateTime.Now - startTime,
        BaseModelScores = boostingModels.Select(m => 1.0 - m.Error).ToArray() // Convert error to accuracy
    };
    
    Console.WriteLine($"?? Adaptive boosting completed! Final score: {result.EnsembleScore:F4}");
    return result;
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- ViewModel Integration -->
                <section class="section" id="ensemble-viewmodel">
                    <h2>?? Ensemble ViewModel Integration</h2>
                    
                    <div class="method">
                        <h3><i class="bi bi-laptop"></i> MVVM Ensemble Management</h3>
                        
                        <div class="code-example">
                            <h4>Ensemble ViewModel Implementation</h4>
                            <pre><code class="language-csharp">// Ensemble management in PythonMachineLearningViewModel
public partial class PythonMachineLearningViewModel : PythonBaseViewModel
{
    // Ensemble properties
    [ObservableProperty] private EnsembleConfiguration ensembleConfig;
    [ObservableProperty] private bool isEnsembleTraining;
    [ObservableProperty] private EnsembleResult currentEnsembleResult;
    [ObservableProperty] private ObservableCollection&lt;BaseModelInfo&gt; baseModels;
    [ObservableProperty] private ObservableCollection&lt;EnsembleComparison&gt; ensembleComparisons;
    
    // Commands
    public IAsyncRelayCommand CreateVotingEnsembleCommand { get; }
    public IAsyncRelayCommand CreateStackingEnsembleCommand { get; }
    public IAsyncRelayCommand CreateBaggingEnsembleCommand { get; }
    public IAsyncRelayCommand CreateBoostingEnsembleCommand { get; }
    public IRelayCommand CompareEnsemblesCommand { get; }
    
    public PythonMachineLearningViewModel(IBeepService beepService, 
                                        IPythonNetRunTimeManager pythonRuntime, 
                                        PythonSessionInfo sessionInfo)
        : base(beepService, pythonRuntime, sessionInfo)
    {
        // Initialize ensemble properties
        EnsembleConfig = new EnsembleConfiguration();
        BaseModels = new ObservableCollection&lt;BaseModelInfo&gt;();
        EnsembleComparisons = new ObservableCollection&lt;EnsembleComparison&gt;();
        
        // Initialize commands
        CreateVotingEnsembleCommand = new AsyncRelayCommand(CreateVotingEnsembleAsync, CanCreateEnsemble);
        CreateStackingEnsembleCommand = new AsyncRelayCommand(CreateStackingEnsembleAsync, CanCreateEnsemble);
        CreateBaggingEnsembleCommand = new AsyncRelayCommand(CreateBaggingEnsembleAsync, CanCreateEnsemble);
        CreateBoostingEnsembleCommand = new AsyncRelayCommand(CreateBoostingEnsembleAsync, CanCreateEnsemble);
        CompareEnsemblesCommand = new RelayCommand(CompareEnsembles);
    }
    
    private async Task CreateVotingEnsembleAsync()
    {
        try
        {
            IsEnsembleTraining = true;
            CurrentWorkflowStage = "Creating Voting Ensemble...";
            
            var baseAlgorithms = EnsembleConfig.SelectedAlgorithms.ToArray();
            var result = await this.TrainEnsembleAsync(EnsembleType.Voting, baseAlgorithms);
            
            if (result.Success)
            {
                CurrentEnsembleResult = result;
                UpdateEnsembleDisplay(result);
                
                CurrentWorkflowStage = $"Voting Ensemble Created - Score: {result.EnsembleScore:F4}";
                ShowSuccessMessage($"Voting ensemble achieved {result.EnsembleScore:F4} score!");
            }
            else
            {
                ShowErrorMessage($"Voting ensemble failed: {result.Message}");
            }
        }
        catch (Exception ex)
        {
            ShowErrorMessage($"Ensemble creation error: {ex.Message}");
        }
        finally
        {
            IsEnsembleTraining = false;
        }
    }
    
    private async Task CreateStackingEnsembleAsync()
    {
        try
        {
            IsEnsembleTraining = true;
            CurrentWorkflowStage = "Creating Stacking Ensemble...";
            
            var baseAlgorithms = EnsembleConfig.SelectedAlgorithms.ToArray();
            var result = await this.TrainEnsembleAsync(EnsembleType.Stacking, baseAlgorithms);
            
            if (result.Success)
            {
                CurrentEnsembleResult = result;
                UpdateEnsembleDisplay(result);
                
                CurrentWorkflowStage = $"Stacking Ensemble Created - Score: {result.EnsembleScore:F4}";
                ShowSuccessMessage($"Stacking ensemble with meta-learner achieved {result.EnsembleScore:F4} score!");
            }
        }
        catch (Exception ex)
        {
            ShowErrorMessage($"Stacking ensemble error: {ex.Message}");
        }
        finally
        {
            IsEnsembleTraining = false;
        }
    }
    
    private void UpdateEnsembleDisplay(EnsembleResult result)
    {
        // Update base models display
        BaseModels.Clear();
        for (int i = 0; i < result.Algorithms.Length; i++)
        {
            BaseModels.Add(new BaseModelInfo
            {
                Algorithm = result.Algorithms[i],
                Score = result.BaseModelScores[i],
                Weight = i < result.ModelWeights?.Length ? result.ModelWeights[i] : 1.0
            });
        }
        
        // Update performance metrics
        CurrentModelMetrics = new ModelPerformanceMetrics
        {
            Accuracy = result.EnsembleScore,
            ModelType = result.EnsembleType.ToString(),
            EstimatorCount = result.EstimatorCount,
            TrainingTime = result.TrainingTime
        };
        
        // Add to comparisons
        EnsembleComparisons.Add(new EnsembleComparison
        {
            EnsembleType = result.EnsembleType,
            Score = result.EnsembleScore,
            EstimatorCount = result.EstimatorCount,
            TrainingTime = result.TrainingTime,
            Timestamp = DateTime.Now
        });
    }
    
    private bool CanCreateEnsemble()
    {
        return !IsEnsembleTraining && 
               IsMLPipelineReady && 
               EnsembleConfig?.SelectedAlgorithms?.Any() == true &&
               EnsembleConfig.SelectedAlgorithms.Count() >= 2;
    }
    
    private void CompareEnsembles()
    {
        // Generate ensemble comparison report
        var report = GenerateEnsembleComparisonReport();
        DisplayEnsembleComparisonDialog(report);
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="method">
                        <h3><i class="bi bi-graph-up"></i> Ensemble Performance Visualization</h3>
                        
                        <div class="code-example">
                            <h4>WPF Ensemble UI Binding</h4>
                            <pre><code class="language-xml">&lt;!-- Ensemble Configuration Panel --&gt;
&lt;GroupBox Header="Ensemble Configuration" Margin="10"&gt;
    &lt;StackPanel&gt;
        &lt;!-- Algorithm Selection --&gt;
        &lt;Label Content="Base Algorithms:" FontWeight="Bold" Margin="5"/&gt;
        &lt;ListBox ItemsSource="{Binding AvailableAlgorithms}" 
                 SelectionMode="Multiple"
                 Height="120" Margin="5"&gt;
            &lt;ListBox.ItemTemplate&gt;
                &lt;DataTemplate&gt;
                    &lt;CheckBox Content="{Binding Name}" 
                              IsChecked="{Binding IsSelected}"
                              Margin="2"/&gt;
                &lt;/DataTemplate&gt;
            &lt;/ListBox.ItemTemplate&gt;
        &lt;/ListBox&gt;
        
        &lt;!-- Ensemble Type Selection --&gt;
        &lt;Grid Margin="10"&gt;
            &lt;Grid.ColumnDefinitions&gt;
                &lt;ColumnDefinition Width="*"/&gt;
                &lt;ColumnDefinition Width="*"/&gt;
                &lt;ColumnDefinition Width="*"/&gt;
                &lt;ColumnDefinition Width="*"/&gt;
            &lt;/Grid.ColumnDefinitions&gt;
            
            &lt;Button Grid.Column="0" Content="??? Voting" 
                    Command="{Binding CreateVotingEnsembleCommand}"
                    IsEnabled="{Binding IsEnsembleTraining, Converter={StaticResource InverseBooleanConverter}}"
                    Style="{StaticResource PrimaryButtonStyle}" Margin="5"/&gt;
            
            &lt;Button Grid.Column="1" Content="?? Stacking" 
                    Command="{Binding CreateStackingEnsembleCommand}"
                    IsEnabled="{Binding IsEnsembleTraining, Converter={StaticResource InverseBooleanConverter}}"
                    Style="{StaticResource InfoButtonStyle}" Margin="5"/&gt;
            
            &lt;Button Grid.Column="2" Content="?? Bagging" 
                    Command="{Binding CreateBaggingEnsembleCommand}"
                    IsEnabled="{Binding IsEnsembleTraining, Converter={StaticResource InverseBooleanConverter}}"
                    Style="{StaticResource WarningButtonStyle}" Margin="5"/&gt;
            
            &lt;Button Grid.Column="3" Content="? Boosting" 
                    Command="{Binding CreateBoostingEnsembleCommand}"
                    IsEnabled="{Binding IsEnsembleTraining, Converter={StaticResource InverseBooleanConverter}}"
                    Style="{StaticResource SuccessButtonStyle}" Margin="5"/&gt;
        &lt;/Grid&gt;
    &lt;/StackPanel&gt;
&lt;/GroupBox&gt;

&lt;!-- Base Models Display --&gt;
&lt;GroupBox Header="Base Models Performance" 
          Visibility="{Binding BaseModels.Count, Converter={StaticResource CountToVisibilityConverter}}"
          Margin="10"&gt;
    &lt;DataGrid ItemsSource="{Binding BaseModels}" 
              AutoGenerateColumns="False" 
              IsReadOnly="True"&gt;
        &lt;DataGrid.Columns&gt;
            &lt;DataGridTextColumn Header="Algorithm" Binding="{Binding Algorithm}" Width="200"/&gt;
            &lt;DataGridTextColumn Header="Score" Binding="{Binding Score, StringFormat=F4}" Width="100"/&gt;
            &lt;DataGridTextColumn Header="Weight" Binding="{Binding Weight, StringFormat=F3}" Width="100"/&gt;
            &lt;DataGridTemplateColumn Header="Performance" Width="150"&gt;
                &lt;DataGridTemplateColumn.CellTemplate&gt;
                    &lt;DataTemplate&gt;
                        &lt;ProgressBar Value="{Binding Score}" Maximum="1" Height="20"
                                     Background="LightGray" Foreground="Green"/&gt;
                    &lt;/DataTemplate&gt;
                &lt;/DataGridTemplateColumn.CellTemplate&gt;
            &lt;/DataGridTemplateColumn&gt;
        &lt;/DataGrid.Columns&gt;
    &lt;/DataGrid&gt;
&lt;/GroupBox&gt;

&lt;!-- Ensemble Comparison --&gt;
&lt;GroupBox Header="Ensemble Performance Comparison" Margin="10"&gt;
    &lt;StackPanel&gt;
        &lt;Button Content="?? Compare All Ensembles" 
                Command="{Binding CompareEnsemblesCommand}"
                Style="{StaticResource InfoButtonStyle}" 
                Margin="10" HorizontalAlignment="Center"/&gt;
        
        &lt;DataGrid ItemsSource="{Binding EnsembleComparisons}" 
                  AutoGenerateColumns="False" 
                  IsReadOnly="True"
                  MaxHeight="200"&gt;
            &lt;DataGrid.Columns&gt;
                &lt;DataGridTextColumn Header="Type" Binding="{Binding EnsembleType}" Width="120"/&gt;
                &lt;DataGridTextColumn Header="Score" Binding="{Binding Score, StringFormat=F4}" Width="80"/&gt;
                &lt;DataGridTextColumn Header="Models" Binding="{Binding EstimatorCount}" Width="80"/&gt;
                &lt;DataGridTextColumn Header="Time" Binding="{Binding TrainingTime, StringFormat=mm\\:ss}" Width="80"/&gt;
                &lt;DataGridTextColumn Header="Created" Binding="{Binding Timestamp, StringFormat=HH:mm:ss}" Width="80"/&gt;
                &lt;DataGridTemplateColumn Header="Rank" Width="60"&gt;
                    &lt;DataGridTemplateColumn.CellTemplate&gt;
                        &lt;DataTemplate&gt;
                            &lt;TextBlock Text="{Binding Rank}" 
                                       HorizontalAlignment="Center"
                                       FontWeight="Bold"
                                       Foreground="{Binding RankColor}"/&gt;
                        &lt;/DataTemplate&gt;
                    &lt;/DataGridTemplateColumn.CellTemplate&gt;
                &lt;/DataGridTemplateColumn&gt;
            &lt;/DataGrid.Columns&gt;
        &lt;/DataGrid&gt;
    &lt;/StackPanel&gt;
&lt;/GroupBox&gt;</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Best Practices -->
                <section class="section" id="ensemble-best-practices">
                    <h2>? Ensemble Best Practices</h2>
                    
                    <div class="tip">
                        <h5><i class="bi bi-lightbulb"></i> Ensemble Design Guidelines</h5>
                        <ul>
                            <li><strong>Diversity is Key:</strong> Use algorithms with different strengths and biases</li>
                            <li><strong>Quality over Quantity:</strong> Better to have fewer high-quality models</li>
                            <li><strong>Validation Strategy:</strong> Use proper cross-validation for ensemble evaluation</li>
                            <li><strong>Computational Trade-offs:</strong> Balance performance gain vs training time</li>
                            <li><strong>Overfitting Prevention:</strong> Monitor ensemble complexity</li>
                            <li><strong>Production Considerations:</strong> Ensure inference time is acceptable</li>
                        </ul>
                    </div>

                    <div class="warning">
                        <h5><i class="bi bi-exclamation-triangle"></i> Common Ensemble Pitfalls</h5>
                        <ul>
                            <li><strong>Similar Models:</strong> Using highly correlated models reduces diversity</li>
                            <li><strong>Data Leakage:</strong> Same preprocessing mistakes in all base models</li>
                            <li><strong>Overfitting Meta-learner:</strong> Too complex stacking models</li>
                            <li><strong>Imbalanced Ensembles:</strong> Not addressing class imbalance properly</li>
                            <li><strong>Computational Overhead:</strong> Ensemble too expensive for production</li>
                        </ul>
                    </div>
                </section>

                <!-- Navigation Links -->
                <div class="nav-links">
                    <a href="automl-integration.html" class="btn-beep">
                        <i class="bi bi-robot"></i> AutoML Integration
                    </a>
                    <a href="hyperparameter-tuning.html" class="btn-beep">
                        <i class="bi bi-sliders"></i> Hyperparameter Tuning
                    </a>
                    <a href="model-interpretability.html" class="btn-beep">
                        <i class="bi bi-eye"></i> Model Interpretability
                    </a>
                </div>

                <!-- Footer -->
                <footer class="documentation-footer">
                    <div class="footer-content">
                        <div class="footer-copyright">
                            <p>&copy; 2024 The Tech Idea - Beep.Python.ML Ensemble Methods Documentation</p>
                            <p>Advanced Ensemble Learning for .NET 6, 7, 8, and 9</p>
                        </div>
                        <div class="footer-links">
                            <a href="#ensemble-overview">Overview</a>
                            <a href="#voting-ensembles">Voting</a>
                            <a href="#stacking-ensembles">Stacking</a>
                            <a href="#bagging-boosting">Bagging & Boosting</a>
                        </div>
                    </div>
                </footer>
            </div>
        </main>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="assets/navigation.js"></script>
</body>
</html>