<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BEEP Workflow Steps Integration - Beep.Python.DataManagement</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link href="../assets/styles.css" rel="stylesheet">
</head>
<body>
    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" onclick="toggleSidebar()">
        <i class="bi bi-list"></i>
    </button>

    <!-- Theme Toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <i class="bi bi-sun-fill" id="theme-icon"></i>
    </button>

    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <!-- Navigation will be loaded dynamically by navigation.js -->
        </aside>

        <!-- Main Content -->
        <main class="content">
            <div class="content-wrapper">
                <!-- Breadcrumb Navigation -->
                <div class="breadcrumb-nav">
                    <a href="../index.html">Home</a>
                    <span>?</span>
                    <a href="../index.html#integration">Integration</a>
                    <span>?</span>
                    <span>Workflow Steps</span>
                </div>

                <!-- Page Header -->
                <div class="page-header">
                    <h1><i class="bi bi-diagram-2"></i> BEEP Workflow Steps Integration</h1>
                    <p class="page-subtitle">Create reusable pandas data processing workflow steps for BEEP's enterprise workflow engine</p>
                </div>

                <!-- Overview -->
                <section class="section" id="overview">
                    <h2>?? Workflow Steps Overview</h2>
                    
                    <div class="note">
                        <h4>?? What are BEEP Workflow Steps?</h4>
                        <p>
                            <strong>BEEP Workflow Steps</strong> are reusable, configurable components that can be orchestrated 
                            in enterprise workflows. They provide a standardized way to integrate pandas operations into 
                            business processes with full audit trails, error handling, and scalability.
                        </p>
                    </div>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4><i class="bi bi-puzzle"></i> Step Components</h4>
                            <p>Atomic data processing units that can be combined and reused</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4><i class="bi bi-arrow-repeat"></i> Workflow Engine</h4>
                            <p>Orchestration engine that manages step execution and dependencies</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4><i class="bi bi-gear"></i> Configuration</h4>
                            <p>Flexible parameter-driven configuration for business users</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4><i class="bi bi-shield-check"></i> Enterprise Features</h4>
                            <p>Auditing, security, monitoring, and compliance built-in</p>
                        </div>
                    </div>
                </section>

                <!-- Core Workflow Step Implementation -->
                <section class="section" id="core-implementation">
                    <h2>??? Core Workflow Step Implementation</h2>
                    
                    <div class="code-example">
                        <h4>1. Base Pandas Workflow Step</h4>
                        <pre><code class="language-csharp">using Beep.Python.DataManagement;
using Beep.Python.WorkflowSteps;
using Microsoft.Extensions.Logging;

[BeepWorkflowStep("PandasDataProcessor")]
public class PandasDataProcessorStep : BaseBeepWorkflowStep
{
    private readonly IPythonPandasManager _pandasManager;
    private readonly IDataQualityService _dataQualityService;
    private readonly ILogger&lt;PandasDataProcessorStep&gt; _logger;
    
    public PandasDataProcessorStep(
        IPythonPandasManager pandasManager,
        IDataQualityService dataQualityService,
        ILogger&lt;PandasDataProcessorStep&gt; logger)
    {
        _pandasManager = pandasManager;
        _dataQualityService = dataQualityService;
        _logger = logger;
    }
    
    public override async Task&lt;WorkflowStepResult&gt; ExecuteAsync(WorkflowStepContext context)
    {
        var stepParams = context.GetParameters&lt;PandasProcessorParameters&gt;();
        var result = new WorkflowStepResult();
        
        try
        {
            _logger.LogInformation("Starting pandas data processing step: {StepName}", context.StepName);
            
            // Initialize session for this workflow execution
            var sessionId = $"workflow-{context.WorkflowInstanceId}-{context.StepId}";
            var sessionConfigured = _pandasManager.ConfigureSessionForUser(context.UserId, sessionId);
            
            if (!sessionConfigured)
            {
                throw new InvalidOperationException($"Failed to configure pandas session for user {context.UserId}");
            }
            
            // Execute the pandas processing pipeline
            var processingResult = await ExecutePandasPipeline(stepParams, context);
            
            // Validate output data quality
            if (stepParams.ValidateOutput)
            {
                await ValidateOutputData(processingResult, stepParams);
            }
            
            // Save outputs to workflow context
            await SaveOutputsToContext(processingResult, context);
            
            // Create workflow result
            result.Success = true;
            result.Data = processingResult.OutputData;
            result.Metrics = processingResult.Metrics;
            result.ExecutionTime = processingResult.ExecutionTime;
            result.Message = $"Processed {processingResult.RecordsProcessed:N0} records successfully";
            
            _logger.LogInformation("Pandas processing step completed successfully: {Records} records processed", 
                processingResult.RecordsProcessed);
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Pandas processing step failed: {Error}", ex.Message);
            
            result.Success = false;
            result.ErrorMessage = ex.Message;
            result.ErrorDetails = ex.StackTrace;
            
            // Save error context for debugging
            await SaveErrorContext(ex, context);
            
            return result;
        }
        finally
        {
            // Cleanup resources
            await CleanupResources(context);
        }
    }
    
    private async Task&lt;PandasProcessingResult&gt; ExecutePandasPipeline(
        PandasProcessorParameters stepParams, 
        WorkflowStepContext context)
    {
        var startTime = DateTime.UtcNow;
        var result = new PandasProcessingResult();
        
        // Load input data
        var inputDataFrame = await LoadInputData(stepParams, context);
        result.InputRecords = GetDataFrameRowCount(inputDataFrame);
        
        // Execute processing operations in sequence
        var currentDataFrame = inputDataFrame;
        var operationResults = new List&lt;OperationResult&gt;();
        
        foreach (var operation in stepParams.Operations)
        {
            _logger.LogDebug("Executing operation: {OperationType}", operation.Type);
            
            var opResult = await ExecuteOperation(currentDataFrame, operation, context);
            operationResults.Add(opResult);
            
            currentDataFrame = opResult.OutputDataFrame;
            
            if (!opResult.Success)
            {
                throw new InvalidOperationException($"Operation {operation.Type} failed: {opResult.ErrorMessage}");
            }
        }
        
        result.OutputDataFrame = currentDataFrame;
        result.RecordsProcessed = GetDataFrameRowCount(currentDataFrame);
        result.OperationResults = operationResults;
        result.ExecutionTime = DateTime.UtcNow - startTime;
        
        // Collect performance metrics
        result.Metrics = await CollectPerformanceMetrics(inputDataFrame, currentDataFrame);
        
        return result;
    }
    
    private async Task&lt;string&gt; LoadInputData(PandasProcessorParameters stepParams, WorkflowStepContext context)
    {
        switch (stepParams.InputSource.Type)
        {
            case WorkflowInputType.PreviousStepOutput:
                return await LoadFromPreviousStep(stepParams.InputSource, context);
                
            case WorkflowInputType.WorkflowVariable:
                return await LoadFromWorkflowVariable(stepParams.InputSource, context);
                
            case WorkflowInputType.FileUpload:
                return await LoadFromFileUpload(stepParams.InputSource, context);
                
            case WorkflowInputType.DatabaseQuery:
                return await LoadFromDatabase(stepParams.InputSource, context);
                
            case WorkflowInputType.WebAPI:
                return await LoadFromWebAPI(stepParams.InputSource, context);
                
            default:
                throw new NotSupportedException($"Input source type {stepParams.InputSource.Type} is not supported");
        }
    }
    
    private async Task&lt;string&gt; LoadFromPreviousStep(WorkflowInputSource source, WorkflowStepContext context)
    {
        var previousStepOutput = await context.GetPreviousStepOutputAsync(source.PreviousStepId);
        
        if (previousStepOutput?.Data is DataFrameReference dataFrameRef)
        {
            return dataFrameRef.DataFrameName;
        }
        else if (previousStepOutput?.Data is string jsonData)
        {
            // Load JSON data into a new DataFrame
            var dataFrameName = $"step_input_{context.StepId}";
            await LoadJsonIntoDataFrame(jsonData, dataFrameName);
            return dataFrameName;
        }
        
        throw new InvalidOperationException($"Previous step {source.PreviousStepId} did not produce compatible data");
    }
    
    private async Task&lt;string&gt; LoadFromDatabase(WorkflowInputSource source, WorkflowStepContext context)
    {
        var connectionString = await context.GetConnectionStringAsync(source.ConnectionName);
        var query = await context.ResolveParametersInText(source.Query);
        
        var dataFrameName = $"db_input_{context.StepId}";
        _pandasManager.ReadSql(dataFrameName, query, connectionString);
        
        _logger.LogInformation("Loaded data from database: {RowCount} rows", GetDataFrameRowCount(dataFrameName));
        
        return dataFrameName;
    }
}</code></pre>
                    </div>

                    <div class="code-example">
                        <h4>2. Operation Execution Engine</h4>
                        <pre><code class="language-csharp">private async Task&lt;OperationResult&gt; ExecuteOperation(
    string inputDataFrame, 
    PandasOperation operation, 
    WorkflowStepContext context)
{
    var result = new OperationResult
    {
        OperationType = operation.Type,
        StartTime = DateTime.UtcNow
    };
    
    try
    {
        var outputDataFrame = $"{inputDataFrame}_{operation.Type.ToString().ToLower()}_{Guid.NewGuid():N}";
        
        switch (operation.Type)
        {
            case PandasOperationType.Filter:
                await ExecuteFilterOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.Transform:
                await ExecuteTransformOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.Aggregate:
                await ExecuteAggregateOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.Join:
                await ExecuteJoinOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.Pivot:
                await ExecutePivotOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.Clean:
                await ExecuteCleanOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.Validate:
                await ExecuteValidateOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            case PandasOperationType.CustomCode:
                await ExecuteCustomCodeOperation(inputDataFrame, outputDataFrame, operation, context);
                break;
                
            default:
                throw new NotSupportedException($"Operation type {operation.Type} is not supported");
        }
        
        result.Success = true;
        result.OutputDataFrame = outputDataFrame;
        result.RecordsProcessed = GetDataFrameRowCount(outputDataFrame);
        result.ExecutionTime = DateTime.UtcNow - result.StartTime;
        
        _logger.LogDebug("Operation {OperationType} completed: {Records} records processed in {Duration}ms",
            operation.Type, result.RecordsProcessed, result.ExecutionTime.TotalMilliseconds);
        
        return result;
    }
    catch (Exception ex)
    {
        result.Success = false;
        result.ErrorMessage = ex.Message;
        result.ExecutionTime = DateTime.UtcNow - result.StartTime;
        
        _logger.LogError(ex, "Operation {OperationType} failed: {Error}", operation.Type, ex.Message);
        
        return result;
    }
}

private async Task ExecuteFilterOperation(
    string inputDataFrame, 
    string outputDataFrame, 
    PandasOperation operation, 
    WorkflowStepContext context)
{
    var filterExpression = await context.ResolveParametersInText(operation.Parameters["expression"].ToString());
    
    string filterCode = $@"
import pandas as pd

# Apply filter expression with safety checks
try:
    # Validate the filter expression for security
    allowed_operations = ['==', '!=', '>', '<', '>=', '<=', 'in', 'not in', 'isin', 'isna', 'notna']
    
    # Apply filter (parameterized to prevent code injection)
    {outputDataFrame} = {inputDataFrame}.query('{filterExpression}')
    
    print(f'Filter applied: {{len({inputDataFrame})}} ? {{len({outputDataFrame})}} rows')
    
except Exception as e:
    print(f'Filter operation failed: {{e}}')
    raise
";
    
    await _pandasManager.ExecutePythonCodeAsync(filterCode);
}

private async Task ExecuteTransformOperation(
    string inputDataFrame, 
    string outputDataFrame, 
    PandasOperation operation, 
    WorkflowStepContext context)
{
    var transformations = operation.Parameters["transformations"] as List&lt;ColumnTransformation&gt;;
    
    string transformCode = $@"
import pandas as pd
import numpy as np

# Start with input DataFrame
{outputDataFrame} = {inputDataFrame}.copy()

transform_log = []
";
    
    foreach (var transform in transformations)
    {
        var expression = await context.ResolveParametersInText(transform.Expression);
        
        transformCode += $@"
# Transform column: {transform.TargetColumn}
try:
    {outputDataFrame}['{transform.TargetColumn}'] = {expression}
    transform_log.append('? {transform.TargetColumn}: {transform.Description}')
except Exception as e:
    transform_log.append('? {transform.TargetColumn}: Failed - ' + str(e))
    raise Exception(f'Transform failed for {{transform.TargetColumn}}: {{e}}')
";
    }
    
    transformCode += @"
print('Transformations applied:')
for log_entry in transform_log:
    print(f'  {log_entry}')
";
    
    await _pandasManager.ExecutePythonCodeAsync(transformCode);
}

private async Task ExecuteAggregateOperation(
    string inputDataFrame, 
    string outputDataFrame, 
    PandasOperation operation, 
    WorkflowStepContext context)
{
    var groupByColumns = operation.Parameters["groupBy"] as List&lt;string&gt;;
    var aggregations = operation.Parameters["aggregations"] as Dictionary&lt;string, List&lt;string&gt;&gt;;
    
    string aggregateCode = $@"
import pandas as pd
import numpy as np

# Perform aggregation
group_columns = {ConvertListToString(groupByColumns)}
aggregation_dict = {ConvertDictionaryToString(aggregations)}

try:
    if group_columns:
        # Group by aggregation
        {outputDataFrame} = {inputDataFrame}.groupby(group_columns).agg(aggregation_dict)
        
        # Flatten column names if multi-level
        if isinstance({outputDataFrame}.columns, pd.MultiIndex):
            {outputDataFrame}.columns = ['_'.join(col).strip() for col in {outputDataFrame}.columns.values]
        
        # Reset index to make group columns regular columns
        {outputDataFrame} = {outputDataFrame}.reset_index()
    else:
        # Overall aggregation (no grouping)
        {outputDataFrame} = pd.DataFrame([{inputDataFrame}.agg(aggregation_dict)])
    
    print(f'Aggregation completed: {{len({inputDataFrame})}} ? {{len({outputDataFrame})}} rows')
    
except Exception as e:
    print(f'Aggregation failed: {{e}}')
    raise
";
    
    await _pandasManager.ExecutePythonCodeAsync(aggregateCode);
}

private async Task ExecuteJoinOperation(
    string inputDataFrame, 
    string outputDataFrame, 
    PandasOperation operation, 
    WorkflowStepContext context)
{
    var rightDataFrameName = operation.Parameters["rightDataFrame"].ToString();
    var joinType = operation.Parameters["joinType"].ToString();
    var leftKeys = operation.Parameters["leftKeys"] as List&lt;string&gt;;
    var rightKeys = operation.Parameters["rightKeys"] as List&lt;string&gt;;
    
    // Load the right DataFrame if it's from another source
    var rightDataFrame = await ResolveDataFrameReference(rightDataFrameName, context);
    
    string joinCode = $@"
import pandas as pd

# Perform join operation
left_keys = {ConvertListToString(leftKeys)}
right_keys = {ConvertListToString(rightKeys)}
join_type = '{joinType.ToLower()}'

try:
    # Validate join keys exist
    missing_left_keys = [key for key in left_keys if key not in {inputDataFrame}.columns]
    missing_right_keys = [key for key in right_keys if key not in {rightDataFrame}.columns]
    
    if missing_left_keys:
        raise ValueError(f'Missing left join keys: {{missing_left_keys}}')
    if missing_right_keys:
        raise ValueError(f'Missing right join keys: {{missing_right_keys}}')
    
    # Perform the join
    if left_keys == right_keys:
        {outputDataFrame} = {inputDataFrame}.merge(
            {rightDataFrame}, 
            on=left_keys, 
            how=join_type,
            suffixes=('_left', '_right')
        )
    else:
        {outputDataFrame} = {inputDataFrame}.merge(
            {rightDataFrame}, 
            left_on=left_keys, 
            right_on=right_keys, 
            how=join_type,
            suffixes=('_left', '_right')
        )
    
    print(f'Join completed: {{len({inputDataFrame})}} + {{len({rightDataFrame})}} ? {{len({outputDataFrame})}} rows')
    
except Exception as e:
    print(f'Join operation failed: {{e}}')
    raise
";
    
    await _pandasManager.ExecutePythonCodeAsync(joinCode);
}</code></pre>
                    </div>
                </section>

                <!-- Specialized Workflow Steps -->
                <section class="section" id="specialized-steps">
                    <h2>?? Specialized Workflow Steps</h2>
                    
                    <div class="code-example">
                        <h4>1. Data Quality Validation Step</h4>
                        <pre><code class="language-csharp">[BeepWorkflowStep("DataQualityValidator")]
public class DataQualityValidatorStep : BaseBeepWorkflowStep
{
    private readonly IPythonPandasManager _pandasManager;
    private readonly IDataQualityService _dataQualityService;
    
    public override async Task&lt;WorkflowStepResult&gt; ExecuteAsync(WorkflowStepContext context)
    {
        var stepParams = context.GetParameters&lt;DataQualityValidatorParameters&gt;();
        var result = new WorkflowStepResult();
        
        try
        {
            // Configure session
            var sessionConfigured = _pandasManager.ConfigureSessionForUser(
                context.UserId, 
                $"validation-{context.WorkflowInstanceId}");
            
            if (!sessionConfigured)
            {
                throw new InvalidOperationException("Failed to configure validation session");
            }
            
            // Load input data
            var dataFrameName = await LoadInputDataFrame(stepParams.InputSource, context);
            
            // Execute comprehensive data quality assessment
            var qualityReport = await _dataQualityService.AssessDataQuality(dataFrameName, stepParams.QualityConfig);
            
            // Apply validation rules
            var validationResults = await ValidateDataQualityRules(dataFrameName, stepParams.ValidationRules);
            
            // Determine if data passes quality threshold
            var qualityScore = CalculateOverallQualityScore(qualityReport, validationResults);
            var passesThreshold = qualityScore >= stepParams.MinimumQualityScore;
            
            // Create detailed validation report
            var validationReport = new DataQualityValidationReport
            {
                DataFrameName = dataFrameName,
                QualityScore = qualityScore,
                PassesValidation = passesThreshold,
                QualityReport = qualityReport,
                ValidationResults = validationResults,
                Timestamp = DateTime.UtcNow
            };
            
            // Save validation artifacts
            await SaveValidationArtifacts(validationReport, context);
            
            result.Success = passesThreshold;
            result.Data = validationReport;
            result.Message = passesThreshold 
                ? $"Data quality validation passed (Score: {qualityScore:F2})"
                : $"Data quality validation failed (Score: {qualityScore:F2}, Required: {stepParams.MinimumQualityScore:F2})";
            
            // Add quality metrics to workflow context
            context.SetVariable("QualityScore", qualityScore);
            context.SetVariable("ValidationPassed", passesThreshold);
            
            return result;
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.ErrorMessage = $"Data quality validation failed: {ex.Message}";
            return result;
        }
    }
    
    private async Task&lt;List&lt;ValidationRuleResult&gt;&gt; ValidateDataQualityRules(
        string dataFrameName, 
        List&lt;DataQualityRule&gt; rules)
    {
        var results = new List&lt;ValidationRuleResult&gt;();
        
        foreach (var rule in rules)
        {
            var ruleResult = await ExecuteValidationRule(dataFrameName, rule);
            results.Add(ruleResult);
        }
        
        return results;
    }
    
    private async Task&lt;ValidationRuleResult&gt; ExecuteValidationRule(string dataFrameName, DataQualityRule rule)
    {
        string validationCode = $@"
import pandas as pd
import numpy as np

df = {dataFrameName}
rule_result = {{
    'rule_name': '{rule.Name}',
    'rule_type': '{rule.Type}',
    'passed': True,
    'violations': [],
    'details': {{}}
}}

try:";
        
        switch (rule.Type)
        {
            case DataQualityRuleType.CompletenessCheck:
                validationCode += $@"
    # Completeness validation
    total_cells = df.size
    missing_cells = df.isnull().sum().sum()
    completeness_percentage = ((total_cells - missing_cells) / total_cells) * 100
    
    rule_result['details']['completeness_percentage'] = completeness_percentage
    rule_result['details']['missing_cells'] = missing_cells
    rule_result['details']['total_cells'] = total_cells
    
    if completeness_percentage < {rule.Threshold}:
        rule_result['passed'] = False
        rule_result['violations'].append(f'Completeness {{completeness_percentage:.2f}}% below threshold {{rule.Threshold}}%')
";
                break;
                
            case DataQualityRuleType.UniquenessCheck:
                validationCode += $@"
    # Uniqueness validation for key columns
    key_columns = {ConvertListToString(rule.Columns)}
    duplicate_count = df.duplicated(subset=key_columns).sum()
    uniqueness_percentage = ((len(df) - duplicate_count) / len(df)) * 100
    
    rule_result['details']['uniqueness_percentage'] = uniqueness_percentage
    rule_result['details']['duplicate_count'] = duplicate_count
    rule_result['details']['total_rows'] = len(df)
    
    if uniqueness_percentage < {rule.Threshold}:
        rule_result['passed'] = False
        rule_result['violations'].append(f'Uniqueness {{uniqueness_percentage:.2f}}% below threshold {{rule.Threshold}}%')
";
                break;
                
            case DataQualityRuleType.ConsistencyCheck:
                validationCode += $@"
    # Consistency validation
    consistency_violations = []
    
    for col in df.columns:
        if df[col].dtype == 'object':
            # Check for inconsistent case, whitespace, etc.
            trimmed_values = df[col].str.strip() if hasattr(df[col], 'str') else df[col]
            case_consistent = df[col].equals(trimmed_values)
            
            if not case_consistent:
                inconsistent_count = (df[col] != trimmed_values).sum()
                consistency_violations.append(f'Column {{col}}: {{inconsistent_count}} inconsistent values')
    
    rule_result['details']['consistency_violations'] = consistency_violations
    
    if len(consistency_violations) > 0:
        rule_result['passed'] = False
        rule_result['violations'].extend(consistency_violations)
";
                break;
        }
        
        validationCode += @"
except Exception as e:
    rule_result['passed'] = False
    rule_result['violations'].append(f'Validation error: {str(e)}')

validation_rule_result = rule_result
";
        
        await _pandasManager.ExecutePythonCodeAsync(validationCode);
        
        // Extract results (simplified)
        return new ValidationRuleResult
        {
            RuleName = rule.Name,
            Passed = true, // Would extract from Python
            Violations = new List&lt;string&gt;()
        };
    }
}</code></pre>
                    </div>

                    <div class="code-example">
                        <h4>2. ETL Pipeline Orchestration Step</h4>
                        <pre><code class="language-csharp">[BeepWorkflowStep("ETLPipelineOrchestrator")]
public class ETLPipelineOrchestratorStep : BaseBeepWorkflowStep
{
    private readonly IPythonPandasManager _pandasManager;
    private readonly IETLPipelineService _etlService;
    private readonly ILogger&lt;ETLPipelineOrchestratorStep&gt; _logger;
    
    public override async Task&lt;WorkflowStepResult&gt; ExecuteAsync(WorkflowStepContext context)
    {
        var stepParams = context.GetParameters&lt;ETLOrchestratorParameters&gt;();
        var result = new WorkflowStepResult();
        
        try
        {
            _logger.LogInformation("Starting ETL pipeline orchestration: {PipelineName}", stepParams.PipelineName);
            
            // Configure dedicated ETL session
            var sessionConfigured = _pandasManager.ConfigureSessionForUser(
                context.UserId, 
                $"etl-{stepParams.PipelineName}-{context.WorkflowInstanceId}");
            
            if (!sessionConfigured)
            {
                throw new InvalidOperationException("Failed to configure ETL session");
            }
            
            // Execute ETL phases
            var extractResult = await ExecuteExtractPhase(stepParams.ExtractConfig, context);
            var transformResult = await ExecuteTransformPhase(stepParams.TransformConfig, context, extractResult);
            var loadResult = await ExecuteLoadPhase(stepParams.LoadConfig, context, transformResult);
            
            // Compile ETL results
            var etlResult = new ETLExecutionResult
            {
                PipelineName = stepParams.PipelineName,
                ExtractResult = extractResult,
                TransformResult = transformResult,
                LoadResult = loadResult,
                TotalExecutionTime = extractResult.ExecutionTime + transformResult.ExecutionTime + loadResult.ExecutionTime,
                RecordsProcessed = transformResult.OutputRecords,
                Success = extractResult.Success && transformResult.Success && loadResult.Success
            };
            
            // Save ETL artifacts and logs
            await SaveETLArtifacts(etlResult, context);
            
            result.Success = etlResult.Success;
            result.Data = etlResult;
            result.ExecutionTime = etlResult.TotalExecutionTime;
            result.Message = etlResult.Success 
                ? $"ETL pipeline completed: {etlResult.RecordsProcessed:N0} records processed"
                : "ETL pipeline failed - check logs for details";
            
            // Update workflow context with ETL results
            context.SetVariable("ETLRecordsProcessed", etlResult.RecordsProcessed);
            context.SetVariable("ETLExecutionTime", etlResult.TotalExecutionTime);
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ETL pipeline orchestration failed: {Error}", ex.Message);
            
            result.Success = false;
            result.ErrorMessage = ex.Message;
            return result;
        }
    }
    
    private async Task&lt;ETLPhaseResult&gt; ExecuteExtractPhase(
        ExtractConfiguration extractConfig, 
        WorkflowStepContext context)
    {
        var phaseResult = new ETLPhaseResult { Phase = "Extract", StartTime = DateTime.UtcNow };
        
        try
        {
            var extractedDataFrames = new List&lt;string&gt;();
            
            foreach (var source in extractConfig.DataSources)
            {
                var dataFrameName = await ExtractFromDataSource(source, context);
                extractedDataFrames.Add(dataFrameName);
                
                _logger.LogInformation("Extracted data from {SourceType}: {DataFrameName}", 
                    source.Type, dataFrameName);
            }
            
            // Combine multiple sources if needed
            string combinedDataFrame;
            if (extractedDataFrames.Count == 1)
            {
                combinedDataFrame = extractedDataFrames[0];
            }
            else
            {
                combinedDataFrame = await CombineExtractedDataFrames(extractedDataFrames, extractConfig);
            }
            
            phaseResult.Success = true;
            phaseResult.OutputDataFrame = combinedDataFrame;
            phaseResult.OutputRecords = GetDataFrameRowCount(combinedDataFrame);
            phaseResult.ExecutionTime = DateTime.UtcNow - phaseResult.StartTime;
            
            return phaseResult;
        }
        catch (Exception ex)
        {
            phaseResult.Success = false;
            phaseResult.ErrorMessage = ex.Message;
            phaseResult.ExecutionTime = DateTime.UtcNow - phaseResult.StartTime;
            
            _logger.LogError(ex, "Extract phase failed: {Error}", ex.Message);
            return phaseResult;
        }
    }
    
    private async Task&lt;string&gt; ExtractFromDataSource(DataSourceConfig source, WorkflowStepContext context)
    {
        var dataFrameName = $"extract_{source.Name}_{Guid.NewGuid():N}";
        
        switch (source.Type)
        {
            case DataSourceType.Database:
                var connectionString = await context.GetConnectionStringAsync(source.ConnectionName);
                var query = await context.ResolveParametersInText(source.Query);
                _pandasManager.ReadSql(dataFrameName, query, connectionString);
                break;
                
            case DataSourceType.File:
                var filePath = await context.ResolveParametersInText(source.FilePath);
                await LoadFileIntoDataFrame(filePath, dataFrameName, source);
                break;
                
            case DataSourceType.WebAPI:
                var apiData = await ExtractFromWebAPI(source, context);
                await LoadJsonIntoDataFrame(apiData, dataFrameName);
                break;
                
            case DataSourceType.WorkflowVariable:
                var variableData = context.GetVariable(source.VariableName);
                await LoadVariableIntoDataFrame(variableData, dataFrameName);
                break;
                
            default:
                throw new NotSupportedException($"Data source type {source.Type} is not supported");
        }
        
        return dataFrameName;
    }
}</code></pre>
                    </div>
                </section>

                <!-- Step Registration and Discovery -->
                <section class="section" id="step-registration">
                    <h2>?? Step Registration and Discovery</h2>
                    
                    <div class="code-example">
                        <h4>Workflow Step Registry and Factory</h4>
                        <pre><code class="language-csharp">public interface IWorkflowStepRegistry
{
    void RegisterStep&lt;T&gt;() where T : BaseBeepWorkflowStep;
    IEnumerable&lt;WorkflowStepDefinition&gt; GetAvailableSteps();
    WorkflowStepDefinition GetStepDefinition(string stepName);
    BaseBeepWorkflowStep CreateStep(string stepName, IServiceProvider serviceProvider);
}

public class WorkflowStepRegistry : IWorkflowStepRegistry
{
    private readonly Dictionary&lt;string, WorkflowStepDefinition&gt; _registeredSteps;
    private readonly ILogger&lt;WorkflowStepRegistry&gt; _logger;
    
    public WorkflowStepRegistry(ILogger&lt;WorkflowStepRegistry&gt; logger)
    {
        _registeredSteps = new Dictionary&lt;string, WorkflowStepDefinition&gt;();
        _logger = logger;
    }
    
    public void RegisterStep&lt;T&gt;() where T : BaseBeepWorkflowStep
    {
        var stepType = typeof(T);
        var stepAttribute = stepType.GetCustomAttribute&lt;BeepWorkflowStepAttribute&gt;();
        
        if (stepAttribute == null)
        {
            throw new InvalidOperationException($"Type {stepType.Name} must have BeepWorkflowStepAttribute");
        }
        
        var definition = new WorkflowStepDefinition
        {
            Name = stepAttribute.Name,
            Description = stepAttribute.Description,
            Category = stepAttribute.Category,
            Type = stepType,
            Parameters = ExtractParameterDefinitions(stepType),
            Icon = stepAttribute.Icon,
            Version = stepAttribute.Version
        };
        
        _registeredSteps[definition.Name] = definition;
        
        _logger.LogInformation("Registered workflow step: {StepName} ({StepType})", 
            definition.Name, stepType.Name);
    }
    
    public IEnumerable&lt;WorkflowStepDefinition&gt; GetAvailableSteps()
    {
        return _registeredSteps.Values.OrderBy(s => s.Category).ThenBy(s => s.Name);
    }
    
    public WorkflowStepDefinition GetStepDefinition(string stepName)
    {
        return _registeredSteps.TryGetValue(stepName, out var definition) ? definition : null;
    }
    
    public BaseBeepWorkflowStep CreateStep(string stepName, IServiceProvider serviceProvider)
    {
        var definition = GetStepDefinition(stepName);
        if (definition == null)
        {
            throw new InvalidOperationException($"Workflow step '{stepName}' is not registered");
        }
        
        return (BaseBeepWorkflowStep)ActivatorUtilities.CreateInstance(serviceProvider, definition.Type);
    }
    
    private List&lt;WorkflowStepParameter&gt; ExtractParameterDefinitions(Type stepType)
    {
        var parameters = new List&lt;WorkflowStepParameter&gt;();
        
        // Look for parameter class in ExecuteAsync method
        var executeMethod = stepType.GetMethod("ExecuteAsync");
        if (executeMethod != null)
        {
            // Find GetParameters&lt;T&gt;() calls to determine parameter types
            // This would typically be done through reflection or code analysis
            // For simplicity, we'll extract from custom attributes
            
            var parameterAttributes = stepType.GetCustomAttributes&lt;WorkflowStepParameterAttribute&gt;();
            
            foreach (var attr in parameterAttributes)
            {
                parameters.Add(new WorkflowStepParameter
                {
                    Name = attr.Name,
                    Type = attr.Type,
                    Description = attr.Description,
                    Required = attr.Required,
                    DefaultValue = attr.DefaultValue
                });
            }
        }
        
        return parameters;
    }
}

// Auto-registration extension for DI container
public static class WorkflowStepRegistrationExtensions
{
    public static IServiceCollection AddPandasWorkflowSteps(this IServiceCollection services)
    {
        services.AddSingleton&lt;IWorkflowStepRegistry, WorkflowStepRegistry&gt;();
        
        // Auto-register all workflow steps in the assembly
        var assembly = Assembly.GetExecutingAssembly();
        var stepTypes = assembly.GetTypes()
            .Where(t => t.IsSubclassOf(typeof(BaseBeepWorkflowStep)) && !t.IsAbstract)
            .ToList();
        
        foreach (var stepType in stepTypes)
        {
            services.AddTransient(stepType);
        }
        
        // Register the auto-discovery service
        services.AddSingleton&lt;IHostedService, WorkflowStepAutoDiscoveryService&gt;();
        
        return services;
    }
}

public class WorkflowStepAutoDiscoveryService : IHostedService
{
    private readonly IWorkflowStepRegistry _registry;
    private readonly ILogger&lt;WorkflowStepAutoDiscoveryService&gt; _logger;
    
    public WorkflowStepAutoDiscoveryService(
        IWorkflowStepRegistry registry,
        ILogger&lt;WorkflowStepAutoDiscoveryService&gt; logger)
    {
        _registry = registry;
        _logger = logger;
    }
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        // Auto-discover and register workflow steps
        var assembly = Assembly.GetExecutingAssembly();
        var stepTypes = assembly.GetTypes()
            .Where(t => t.IsSubclassOf(typeof(BaseBeepWorkflowStep)) && !t.IsAbstract)
            .Where(t => t.GetCustomAttribute&lt;BeepWorkflowStepAttribute&gt;() != null);
        
        foreach (var stepType in stepTypes)
        {
            try
            {
                var registerMethod = _registry.GetType().GetMethod("RegisterStep")
                    .MakeGenericMethod(stepType);
                registerMethod.Invoke(_registry, null);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to register workflow step: {StepType}", stepType.Name);
            }
        }
        
        var registeredCount = _registry.GetAvailableSteps().Count();
        _logger.LogInformation("Auto-discovered and registered {Count} pandas workflow steps", registeredCount);
        
        return Task.CompletedTask;
    }
    
    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;
}</code></pre>
                    </div>
                </section>

                <!-- Configuration and Parameters -->
                <section class="section" id="configuration">
                    <h2>?? Step Configuration and Parameters</h2>
                    
                    <div class="code-example">
                        <h4>Parameter Classes and Validation</h4>
                        <pre><code class="language-csharp">// Base parameter class with validation
public abstract class BaseWorkflowStepParameters
{
    public virtual async Task&lt;ValidationResult&gt; ValidateAsync()
    {
        var validationResult = new ValidationResult();
        
        // Use data annotations for validation
        var validationContext = new ValidationContext(this);
        var validationResults = new List&lt;System.ComponentModel.DataAnnotations.ValidationResult&gt;();
        
        bool isValid = Validator.TryValidateObject(this, validationContext, validationResults, true);
        
        if (!isValid)
        {
            validationResult.IsValid = false;
            validationResult.Errors = validationResults.Select(r => r.ErrorMessage).ToList();
        }
        
        return validationResult;
    }
}

// Pandas Data Processor Parameters
public class PandasProcessorParameters : BaseWorkflowStepParameters
{
    [Required]
    public WorkflowInputSource InputSource { get; set; }
    
    [Required]
    public List&lt;PandasOperation&gt; Operations { get; set; } = new();
    
    public bool ValidateOutput { get; set; } = true;
    
    public List&lt;WorkflowOutputTarget&gt; OutputTargets { get; set; } = new();
    
    public Dictionary&lt;string, object&gt; GlobalParameters { get; set; } = new();
    
    public override async Task&lt;ValidationResult&gt; ValidateAsync()
    {
        var result = await base.ValidateAsync();
        
        // Custom validation logic
        if (Operations?.Any() != true)
        {
            result.IsValid = false;
            result.Errors.Add("At least one operation must be specified");
        }
        
        // Validate each operation
        foreach (var operation in Operations ?? new List&lt;PandasOperation&gt;())
        {
            var operationValidation = await ValidateOperation(operation);
            if (!operationValidation.IsValid)
            {
                result.IsValid = false;
                result.Errors.AddRange(operationValidation.Errors.Select(e => $"Operation {operation.Type}: {e}"));
            }
        }
        
        return result;
    }
    
    private async Task&lt;ValidationResult&gt; ValidateOperation(PandasOperation operation)
    {
        var result = new ValidationResult();
        
        switch (operation.Type)
        {
            case PandasOperationType.Filter:
                if (!operation.Parameters.ContainsKey("expression"))
                {
                    result.IsValid = false;
                    result.Errors.Add("Filter operation requires 'expression' parameter");
                }
                break;
                
            case PandasOperationType.Join:
                var requiredJoinParams = new[] { "rightDataFrame", "leftKeys", "rightKeys", "joinType" };
                var missingParams = requiredJoinParams.Where(p => !operation.Parameters.ContainsKey(p)).ToList();
                
                if (missingParams.Any())
                {
                    result.IsValid = false;
                    result.Errors.Add($"Join operation missing required parameters: {string.Join(", ", missingParams)}");
                }
                break;
                
            case PandasOperationType.Aggregate:
                if (!operation.Parameters.ContainsKey("aggregations"))
                {
                    result.IsValid = false;
                    result.Errors.Add("Aggregate operation requires 'aggregations' parameter");
                }
                break;
        }
        
        return result;
    }
}

// ETL Orchestrator Parameters
public class ETLOrchestratorParameters : BaseWorkflowStepParameters
{
    [Required]
    [StringLength(100, MinimumLength = 1)]
    public string PipelineName { get; set; }
    
    [Required]
    public ExtractConfiguration ExtractConfig { get; set; }
    
    [Required]
    public TransformConfiguration TransformConfig { get; set; }
    
    [Required]
    public LoadConfiguration LoadConfig { get; set; }
    
    public bool EnableParallelProcessing { get; set; } = false;
    
    public int MaxDegreeOfParallelism { get; set; } = Environment.ProcessorCount;
    
    public TimeSpan Timeout { get; set; } = TimeSpan.FromHours(1);
}

// Data Quality Validator Parameters
public class DataQualityValidatorParameters : BaseWorkflowStepParameters
{
    [Required]
    public WorkflowInputSource InputSource { get; set; }
    
    [Required]
    [Range(0, 100)]
    public decimal MinimumQualityScore { get; set; } = 80m;
    
    public List&lt;DataQualityRule&gt; ValidationRules { get; set; } = new();
    
    public DataQualityConfiguration QualityConfig { get; set; } = new();
    
    public bool FailOnQualityThreshold { get; set; } = true;
    
    public string ValidationReportPath { get; set; }
}

// Parameter attribute for step metadata
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class WorkflowStepParameterAttribute : Attribute
{
    public string Name { get; set; }
    public string Type { get; set; }
    public string Description { get; set; }
    public bool Required { get; set; }
    public object DefaultValue { get; set; }
    
    public WorkflowStepParameterAttribute(string name, string type, string description, bool required = false)
    {
        Name = name;
        Type = type;
        Description = description;
        Required = required;
    }
}</code></pre>
                    </div>
                </section>

                <!-- Best Practices -->
                <section class="section" id="best-practices">
                    <h2>? Workflow Step Best Practices</h2>
                    
                    <div class="tip">
                        <h4>?? Design Principles</h4>
                        <ul>
                            <li><strong>Single Responsibility:</strong> Each step should have one clear purpose</li>
                            <li><strong>Idempotency:</strong> Steps should produce the same result when run multiple times</li>
                            <li><strong>Error Handling:</strong> Comprehensive error handling with meaningful messages</li>
                            <li><strong>Resource Management:</strong> Proper cleanup of DataFrames and sessions</li>
                        </ul>
                    </div>

                    <div class="tip">
                        <h4>?? Implementation Guidelines</h4>
                        <ul>
                            <li><strong>Parameter Validation:</strong> Validate all inputs before execution</li>
                            <li><strong>Logging:</strong> Comprehensive logging for troubleshooting and auditing</li>
                            <li><strong>Performance:</strong> Monitor and optimize for large datasets</li>
                            <li><strong>Security:</strong> Sanitize inputs and prevent code injection</li>
                        </ul>
                    </div>

                    <div class="warning">
                        <h4>?? Common Pitfalls</h4>
                        <ul>
                            <li><strong>Memory Leaks:</strong> Always clean up DataFrames after use</li>
                            <li><strong>Session Conflicts:</strong> Use unique session IDs for concurrent executions</li>
                            <li><strong>Parameter Injection:</strong> Sanitize dynamic parameters to prevent code injection</li>
                            <li><strong>Resource Limits:</strong> Handle large datasets with chunking or streaming</li>
                        </ul>
                    </div>
                </section>

                <!-- Navigation Links -->
                <div class="nav-links">
                    <a href="dependency-injection.html" class="btn-beep">
                        <i class="bi bi-arrow-left"></i> Dependency Injection
                    </a>
                    <a href="enterprise-deployment.html" class="btn-beep">
                        <i class="bi bi-arrow-right"></i> Enterprise Deployment
                    </a>
                </div>

                <!-- Footer -->
                <footer class="documentation-footer">
                    <div class="footer-content">
                        <div class="footer-copyright">
                            <p>&copy; 2024 The Tech Idea - Beep.Python.DataManagement Documentation</p>
                        </div>
                        <div class="footer-links">
                            <a href="../index.html">Home</a>
                            <a href="../getting-started.html">Getting Started</a>
                            <a href="../api/PythonPandasManager.html">API Reference</a>
                        </div>
                    </div>
                </footer>
            </div>
        </main>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="../assets/navigation.js"></script>
</body>
</html>