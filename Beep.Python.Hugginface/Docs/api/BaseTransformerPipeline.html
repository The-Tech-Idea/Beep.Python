<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BaseTransformerPipeline API - Beep.Python.AI.Transformers</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link href="../assets/styles.css" rel="stylesheet">
</head>

<body>
    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" onclick="toggleSidebar()">
        <i class="bi bi-list"></i>
    </button>

    <!-- Theme Toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <i class="bi bi-sun-fill" id="theme-icon"></i>
    </button>

    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <!-- Navigation will be loaded dynamically by navigation.js -->
        </aside>

        <!-- Main Content -->
        <main class="content">
            <div class="content-wrapper">
                <!-- Breadcrumb Navigation -->
                <div class="breadcrumb-nav">
                    <a href="../index.html">Home</a>
                    <span>‚Ä∫</span>
                    <a href="../index.html#core-api">Core API</a>
                    <span>‚Ä∫</span>
                    <span>BaseTransformerPipeline</span>
                </div>

                <!-- Page Header -->
                <div class="page-header">
                    <h1><i class="bi bi-layers"></i> BaseTransformerPipeline Abstract Class</h1>
                    <p class="page-subtitle">Abstract base class providing core functionality for all transformer pipeline implementations
                    </p>
                </div>

                <!-- Class Info -->
                <div class="class-info">
                    <div class="class-namespace">
                        <strong>Namespace:</strong> Beep.Python.AI.Transformers<br>
                        <strong>Assembly:</strong> Beep.Python.AI.Transformers.dll<br>
                        <strong>Package:</strong> Beep.Python.AI.Transformers
                    </div>
                    <div class="class-implements">
                        <strong>Inheritance:</strong> Object ‚Üí BaseTransformerPipeline<br>
                        <strong>Implements:</strong> ITransformerPipeLine, IDisposable<br>
                        <strong>Derived Types:</strong> OpenAITransformerPipeline, AzureTransformerPipeline, HuggingFaceTransformerPipeline, etc.
                    </div>
                </div>

                <!-- Overview Section -->
                <section class="section" id="overview">
                    <h2>üìã Overview</h2>
                    <p>
                        The <code>BaseTransformerPipeline</code> abstract class serves as the foundation for all transformer pipeline implementations
                        in the Beep.Python.AI.Transformers library. It provides common functionality, error handling, logging, and standardized
                        patterns that all concrete pipeline implementations inherit and extend.
                    </p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4><i class="bi bi-gear"></i> Common Infrastructure</h4>
                            <p>Shared logging, error handling, and configuration management</p>
                        </div>
                        <div class="feature-card">
                            <h4><i class="bi bi-shield-check"></i> Validation Framework</h4>
                            <p>Input validation, security checks, and data sanitization</p>
                        </div>
                        <div class="feature-card">
                            <h4><i class="bi bi-stopwatch"></i> Performance Monitoring</h4>
                            <p>Built-in timing, metrics collection, and performance tracking</p>
                        </div>
                        <div class="feature-card">
                            <h4><i class="bi bi-arrow-repeat"></i> Retry Logic</h4>
                            <p>Configurable retry mechanisms and circuit breaker patterns</p>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <h4>üèóÔ∏è Architecture Benefits</h4>
                        <ul>
                            <li><strong>Consistency:</strong> Standardized behavior across all pipeline implementations</li>
                            <li><strong>Extensibility:</strong> Easy to add new AI providers with minimal code</li>
                            <li><strong>Maintainability:</strong> Centralized common functionality reduces duplication</li>
                            <li><strong>Reliability:</strong> Built-in error handling and recovery mechanisms</li>
                            <li><strong>Observability:</strong> Comprehensive logging and monitoring capabilities</li>
                        </ul>
                    </div>
                </section>

                <!-- Constructor Section -->
                <section class="section" id="constructor">
                    <h2>üîß Constructor</h2>

                    <div class="code-example">
                        <h4>BaseTransformerPipeline(IPythonRunTimeManager, IPythonCodeExecuteManager)</h4>
                        <pre><code class="language-csharp">protected BaseTransformerPipeline(
    IPythonRunTimeManager pythonRunTimeManager,
    IPythonCodeExecuteManager executeManager
)</code></pre>
                        <h5>Parameters</h5>
                        <ul>
                            <li><code>pythonRunTimeManager</code> - Python runtime management interface</li>
                            <li><code>executeManager</code> - Python code execution interface</li>
                        </ul>
                        <p><strong>Note:</strong> This constructor is protected as the class is abstract and can only be called by derived classes.</p>
                    </div>
                </section>

                <!-- Properties Section -->
                <section class="section" id="properties">
                    <h2>üè∑Ô∏è Properties</h2>

                    <div class="method">
                        <h3>IsInitialized</h3>
                        <pre><code class="language-csharp">public bool IsInitialized { get; protected set; }</code></pre>
                        <p>Gets a value indicating whether the pipeline has been successfully initialized.</p>
                    </div>

                    <div class="method">
                        <h3>CurrentProvider</h3>
                        <pre><code class="language-csharp">public TransformerModelSource CurrentProvider { get; protected set; }</code></pre>
                        <p>Gets the current AI provider being used by the pipeline.</p>
                    </div>

                    <div class="method">
                        <h3>CurrentModel</h3>
                        <pre><code class="language-csharp">public TransformerModelInfo? CurrentModel { get; protected set; }</code></pre>
                        <p>Gets information about the currently loaded model.</p>
                    </div>

                    <div class="method">
                        <h3>SupportedTasks</h3>
                        <pre><code class="language-csharp">public virtual List&lt;TransformerTask&gt; SupportedTasks { get; }</code></pre>
                        <p>Gets the list of tasks supported by this pipeline implementation.</p>
                    </div>

                    <div class="method">
                        <h3>Logger</h3>
                        <pre><code class="language-csharp">protected ILogger Logger { get; }</code></pre>
                        <p>Gets the logger instance for this pipeline.</p>
                    </div>
                </section>

                <!-- Abstract Methods Section -->
                <section class="section" id="abstract-methods">
                    <h2>üî® Abstract Methods</h2>
                    <p>These methods must be implemented by all derived pipeline classes:</p>

                    <div class="method">
                        <h3>InitializeAsync</h3>
                        <pre><code class="language-csharp">public abstract Task&lt;bool&gt; InitializeAsync(TransformerPipelineConfig config);</code></pre>
                        <p>Initializes the pipeline with provider-specific configuration. Must be implemented by derived classes.</p>
                    </div>

                    <div class="method">
                        <h3>LoadModelAsync</h3>
                        <pre><code class="language-csharp">public abstract Task&lt;bool&gt; LoadModelAsync(
    TransformerModelInfo modelInfo, 
    TransformerTask taskType, 
    Dictionary&lt;string, object&gt;? modelConfig = null
);</code></pre>
                        <p>Loads a specific model for the given task type. Implementation varies by provider.</p>
                    </div>

                    <div class="method">
                        <h3>GetSupportedTasks</h3>
                        <pre><code class="language-csharp">public abstract List&lt;TransformerTask&gt; GetSupportedTasks();</code></pre>
                        <p>Returns the list of tasks supported by the specific provider implementation.</p>
                    </div>
                </section>

                <!-- Virtual Methods Section -->
                <section class="section" id="virtual-methods">
                    <h2>üîÑ Virtual Methods</h2>
                    <p>These methods have default implementations but can be overridden by derived classes:</p>

                    <div class="method">
                        <h3>GenerateTextAsync</h3>
                        <pre><code class="language-csharp">public virtual async Task&lt;TransformerResult&lt;string&gt;&gt; GenerateTextAsync(
    string prompt, 
    TextGenerationParameters? parameters = null
)</code></pre>
                        <p>Base implementation for text generation with common validation and error handling.</p>
                    </div>

                    <div class="method">
                        <h3>ClassifyTextAsync</h3>
                        <pre><code class="language-csharp">public virtual async Task&lt;TransformerResult&lt;ClassificationResult&gt;&gt; ClassifyTextAsync(
    string text, 
    List&lt;string&gt; labels, 
    ClassificationParameters? parameters = null
)</code></pre>
                        <p>Base implementation for text classification with validation and formatting.</p>
                    </div>

                    <div class="method">
                        <h3>GetEmbeddingsAsync</h3>
                        <pre><code class="language-csharp">public virtual async Task&lt;TransformerResult&lt;List&lt;float[]&gt;&gt;&gt; GetEmbeddingsAsync(
    List&lt;string&gt; texts, 
    EmbeddingParameters? parameters = null
)</code></pre>
                        <p>Base implementation for generating text embeddings.</p>
                    </div>

                    <div class="method">
                        <h3>ValidateConfiguration</h3>
                        <pre><code class="language-csharp">protected virtual bool ValidateConfiguration(TransformerPipelineConfig config)</code></pre>
                        <p>Validates the pipeline configuration. Can be extended by derived classes for provider-specific validation.</p>
                    </div>

                    <div class="method">
                        <h3>HandleError</h3>
                        <pre><code class="language-csharp">protected virtual TransformerResult&lt;T&gt; HandleError&lt;T&gt;(Exception ex, string operation)</code></pre>
                        <p>Handles errors and converts them to standardized result objects.</p>
                    </div>
                </section>

                <!-- Helper Methods Section -->
                <section class="section" id="helper-methods">
                    <h2>üõ†Ô∏è Helper Methods</h2>

                    <div class="method">
                        <h3>LogOperation</h3>
                        <pre><code class="language-csharp">protected void LogOperation(string operation, Dictionary&lt;string, object&gt;? parameters = null)</code></pre>
                        <p>Logs pipeline operations with structured data for monitoring and debugging.</p>
                    </div>

                    <div class="method">
                        <h3>MeasureExecutionTime</h3>
                        <pre><code class="language-csharp">protected async Task&lt;(T result, TimeSpan duration)&gt; MeasureExecutionTime&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; operation)</code></pre>
                        <p>Measures execution time for operations and includes timing in results.</p>
                    </div>

                    <div class="method">
                        <h3>ValidateInput</h3>
                        <pre><code class="language-csharp">protected bool ValidateInput(string input, int maxLength = 0, bool allowEmpty = false)</code></pre>
                        <p>Validates input text for common requirements like length limits and content filtering.</p>
                    </div>

                    <div class="method">
                        <h3>SanitizePrompt</h3>
                        <pre><code class="language-csharp">protected string SanitizePrompt(string prompt)</code></pre>
                        <p>Sanitizes user input to prevent injection attacks and ensure safe processing.</p>
                    </div>

                    <div class="method">
                        <h3>CreateSuccessResult</h3>
                        <pre><code class="language-csharp">protected TransformerResult&lt;T&gt; CreateSuccessResult&lt;T&gt;(T data, Dictionary&lt;string, object&gt;? metadata = null)</code></pre>
                        <p>Creates a successful result object with consistent formatting.</p>
                    </div>

                    <div class="method">
                        <h3>CreateErrorResult</h3>
                        <pre><code class="language-csharp">protected TransformerResult&lt;T&gt; CreateErrorResult&lt;T&gt;(string error, string? errorCode = null)</code></pre>
                        <p>Creates an error result object with standardized error information.</p>
                    </div>
                </section>

                <!-- Implementation Example -->
                <section class="section" id="implementation-example">
                    <h2>üí° Implementation Example</h2>
                    <p>Here's how to create a custom pipeline by inheriting from BaseTransformerPipeline:</p>

                    <div class="code-example">
                        <h4>Custom Pipeline Implementation</h4>
                        <pre><code class="language-csharp">public class CustomAITransformerPipeline : BaseTransformerPipeline
{
    private readonly ICustomAIClient _aiClient;
    private CustomAIConfig _config;

    public CustomAITransformerPipeline(
        IPythonRunTimeManager pythonRunTimeManager,
        IPythonCodeExecuteManager executeManager,
        ICustomAIClient aiClient) 
        : base(pythonRunTimeManager, executeManager)
    {
        _aiClient = aiClient;
    }

    public override async Task&lt;bool&gt; InitializeAsync(TransformerPipelineConfig config)
    {
        try
        {
            // Validate configuration using base class helper
            if (!ValidateConfiguration(config))
            {
                Logger.LogError("Invalid configuration provided");
                return false;
            }

            // Extract custom configuration
            _config = new CustomAIConfig
            {
                ApiKey = config.GetValue&lt;string&gt;("api_key"),
                BaseUrl = config.GetValue&lt;string&gt;("base_url") ?? "https://api.customai.com",
                Timeout = config.GetValue&lt;int&gt;("timeout") ?? 60
            };

            // Initialize the AI client
            await _aiClient.InitializeAsync(_config);

            // Log successful initialization
            LogOperation("Initialize", new Dictionary&lt;string, object&gt;
            {
                ["provider"] = "CustomAI",
                ["base_url"] = _config.BaseUrl
            });

            IsInitialized = true;
            CurrentProvider = TransformerModelSource.Custom;
            
            return true;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize CustomAI pipeline");
            return false;
        }
    }

    public override async Task&lt;bool&gt; LoadModelAsync(
        TransformerModelInfo modelInfo, 
        TransformerTask taskType, 
        Dictionary&lt;string, object&gt;? modelConfig = null)
    {
        try
        {
            if (!IsInitialized)
            {
                throw new InvalidOperationException("Pipeline must be initialized before loading models");
            }

            // Validate model compatibility
            if (!GetSupportedTasks().Contains(taskType))
            {
                throw new NotSupportedException($"Task {taskType} is not supported by CustomAI");
            }

            // Load model using provider-specific logic
            var loadResult = await _aiClient.LoadModelAsync(modelInfo.Name, taskType);
            
            if (loadResult.Success)
            {
                CurrentModel = modelInfo;
                
                LogOperation("LoadModel", new Dictionary&lt;string, object&gt;
                {
                    ["model"] = modelInfo.Name,
                    ["task"] = taskType.ToString()
                });
                
                return true;
            }

            Logger.LogError($"Failed to load model: {loadResult.Error}");
            return false;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading model {ModelName} for task {TaskType}", 
                modelInfo.Name, taskType);
            return false;
        }
    }

    public override async Task&lt;TransformerResult&lt;string&gt;&gt; GenerateTextAsync(
        string prompt, 
        TextGenerationParameters? parameters = null)
    {
        try
        {
            // Use base class input validation
            if (!ValidateInput(prompt, maxLength: 10000))
            {
                return CreateErrorResult&lt;string&gt;("Invalid prompt provided", "INVALID_INPUT");
            }

            // Sanitize the prompt using base class helper
            var sanitizedPrompt = SanitizePrompt(prompt);

            // Measure execution time using base class helper
            var (result, duration) = await MeasureExecutionTime(async () =>
            {
                return await _aiClient.GenerateTextAsync(sanitizedPrompt, parameters);
            });

            if (result.Success)
            {
                // Create success result with metadata
                return CreateSuccessResult(result.Text, new Dictionary&lt;string, object&gt;
                {
                    ["execution_time_ms"] = duration.TotalMilliseconds,
                    ["model"] = CurrentModel?.Name ?? "unknown",
                    ["provider"] = "CustomAI"
                });
            }

            return CreateErrorResult&lt;string&gt;(result.Error, "GENERATION_FAILED");
        }
        catch (Exception ex)
        {
            // Use base class error handling
            return HandleError&lt;string&gt;(ex, "GenerateText");
        }
    }

    public override List&lt;TransformerTask&gt; GetSupportedTasks()
    {
        return new List&lt;TransformerTask&gt;
        {
            TransformerTask.TextGeneration,
            TransformerTask.TextClassification,
            TransformerTask.Summarization,
            TransformerTask.QuestionAnswering
        };
    }

    protected override bool ValidateConfiguration(TransformerPipelineConfig config)
    {
        // Call base validation first
        if (!base.ValidateConfiguration(config))
            return false;

        // Add custom validation
        if (!config.ContainsKey("api_key") || string.IsNullOrEmpty(config["api_key"]?.ToString()))
        {
            Logger.LogError("API key is required for CustomAI pipeline");
            return false;
        }

        return true;
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _aiClient?.Dispose();
        }
        
        base.Dispose(disposing);
    }
}</code></pre>
                    </div>
                </section>

                <!-- Error Handling Patterns -->
                <section class="section" id="error-patterns">
                    <h2>üõ°Ô∏è Error Handling Patterns</h2>

                    <div class="code-example">
                        <h4>Standardized Error Handling</h4>
                        <pre><code class="language-csharp">// Example of using base class error handling in derived classes
public override async Task&lt;TransformerResult&lt;ClassificationResult&gt;&gt; ClassifyTextAsync(
    string text, 
    List&lt;string&gt; labels, 
    ClassificationParameters? parameters = null)
{
    try
    {
        // Input validation using base class helpers
        if (!ValidateInput(text))
        {
            return CreateErrorResult&lt;ClassificationResult&gt;(
                "Input text is invalid or too long", 
                "INVALID_INPUT");
        }

        if (labels == null || !labels.Any())
        {
            return CreateErrorResult&lt;ClassificationResult&gt;(
                "Classification labels cannot be empty", 
                "INVALID_LABELS");
        }

        // Provider-specific implementation
        var result = await PerformClassification(text, labels, parameters);
        
        return CreateSuccessResult(result);
    }
    catch (TimeoutException ex)
    {
        Logger.LogWarning(ex, "Classification request timed out");
        return CreateErrorResult&lt;ClassificationResult&gt;(
            "Request timed out. Try again or reduce input size.", 
            "TIMEOUT");
    }
    catch (UnauthorizedAccessException ex)
    {
        Logger.LogError(ex, "Authentication failed");
        return CreateErrorResult&lt;ClassificationResult&gt;(
            "Authentication failed. Check your API credentials.", 
            "AUTH_FAILED");
    }
    catch (Exception ex)
    {
        // Use base class comprehensive error handling
        return HandleError&lt;ClassificationResult&gt;(ex, "ClassifyText");
    }
}</code></pre>
                    </div>
                </section>

                <!-- Best Practices -->
                <section class="section" id="best-practices">
                    <h2>‚úÖ Best Practices for Implementation</h2>

                    <div class="tip">
                        <h4>üèóÔ∏è Implementation Guidelines</h4>
                        <ul>
                            <li><strong>Always call base methods:</strong> Use base class validation and error handling</li>
                            <li><strong>Consistent logging:</strong> Use the provided Logger for all operations</li>
                            <li><strong>Error codes:</strong> Use standardized error codes for common scenarios</li>
                            <li><strong>Resource management:</strong> Properly dispose of resources in derived classes</li>
                            <li><strong>Configuration validation:</strong> Extend base validation with provider-specific checks</li>
                        </ul>
                    </div>

                    <div class="warning">
                        <h4>‚ö†Ô∏è Common Pitfalls</h4>
                        <ul>
                            <li><strong>Skipping base validation:</strong> Always call base.ValidateConfiguration()</li>
                            <li><strong>Inconsistent error handling:</strong> Use CreateErrorResult() for consistency</li>
                            <li><strong>Missing disposal:</strong> Override Dispose() if you have additional resources</li>
                            <li><strong>Blocking operations:</strong> Keep all operations async where possible</li>
                        </ul>
                    </div>

                    <div class="note">
                        <h4>üéØ Performance Considerations</h4>
                        <ul>
                            <li><strong>Caching:</strong> Cache expensive operations like model loading</li>
                            <li><strong>Connection pooling:</strong> Reuse connections where possible</li>
                            <li><strong>Async patterns:</strong> Use ConfigureAwait(false) for library code</li>
                            <li><strong>Memory management:</strong> Dispose of large objects promptly</li>
                        </ul>
                    </div>
                </section>

                <!-- Navigation Links -->
                <div class="nav-links">
                    <a href="ITransformerPipeLine.html" class="btn-beep">
                        <i class="bi bi-arrow-left"></i> ITransformerPipeLine
                    </a>
                    <a href="TransformerPipelineFactory.html" class="btn-beep">
                        <i class="bi bi-arrow-right"></i> TransformerPipelineFactory
                    </a>
                </div>

                <!-- Footer -->
                <footer class="documentation-footer">
                    <div class="footer-content">
                        <div class="footer-copyright">
                            <p>&copy; 2024 The Tech Idea - Beep.Python.AI.Transformers API Documentation</p>
                        </div>
                        <div class="footer-links">
                            <a href="../index.html">Home</a>
                            <a href="ITransformerPipeLine.html">ITransformerPipeLine</a>
                            <a href="TransformerPipelineFactory.html">Pipeline Factory</a>
                        </div>
                    </div>
                </footer>
            </div>
        </main>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="../assets/navigation.js"></script>
</body>

</html>