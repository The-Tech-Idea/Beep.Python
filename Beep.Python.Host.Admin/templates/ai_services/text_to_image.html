{% extends "ai_services/base_service.html" %}

{% block service_content %}
<!-- Text to Image Service Panel -->
<div class="row mt-4">
    <div class="col-12">
        <div class="card bg-dark border-secondary">
            <div class="card-header border-secondary">
                <h5 class="mb-0"><i class="bi bi-image me-2"></i>Generate Image from Text</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="model-select" class="form-label">Model</label>
                    <select class="form-select" id="model-select">
                        <!-- Models will be loaded dynamically -->
                    </select>
                    <small class="text-muted">Select the image generation model to use</small>
                </div>
                
                <div class="mb-3">
                    <label for="prompt-input" class="form-label">Text Prompt</label>
                    <textarea class="form-control" id="prompt-input" rows="3" placeholder="Enter a description of the image you want to generate..."></textarea>
                    <small class="text-muted">Describe the image you want to create</small>
                </div>
                
                <div class="row mb-3">
                    <div class="col-md-6">
                        <label for="negative-prompt" class="form-label">Negative Prompt (Optional)</label>
                        <textarea class="form-control" id="negative-prompt" rows="2" placeholder="Things to avoid in the image..."></textarea>
                    </div>
                    <div class="col-md-6">
                        <label for="image-size" class="form-label">Image Size</label>
                        <select class="form-select" id="image-size">
                            <option value="512x512">512x512 (SD 1.5)</option>
                            <option value="768x768">768x768</option>
                            <option value="1024x1024" selected>1024x1024 (SDXL)</option>
                            <option value="2048x2048">2048x2048 (UltraFlux)</option>
                            <option value="4096x4096">4096x4096 (UltraFlux)</option>
                            <option value="512x768">512x768 (Portrait)</option>
                            <option value="768x512">768x512 (Landscape)</option>
                        </select>
                    </div>
                </div>
                
                <div class="row mb-3">
                    <div class="col-md-6">
                        <label for="num-steps" class="form-label">Number of Steps</label>
                        <input type="number" class="form-control" id="num-steps" min="10" max="100" value="50">
                        <small class="text-muted">More steps = better quality but slower (10-100)</small>
                    </div>
                    <div class="col-md-6">
                        <label for="guidance-scale" class="form-label">Guidance Scale</label>
                        <input type="number" class="form-control" id="guidance-scale" min="1" max="20" step="0.5" value="7.5">
                        <small class="text-muted">How closely to follow the prompt (1-20)</small>
                    </div>
                </div>
                
                <!-- SDXL/UltraFlux Advanced Options -->
                <div class="row mb-3" id="sdxl-options" style="display: none;">
                    <div class="col-md-6">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="use-refiner">
                            <label class="form-check-label" for="use-refiner">
                                Use Refiner (SDXL Base + Refiner)
                            </label>
                            <small class="text-muted d-block">Higher quality with base+refiner ensemble (80/20 split)</small>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="use-cpu-offload">
                            <label class="form-check-label" for="use-cpu-offload">
                                CPU Offloading
                            </label>
                            <small class="text-muted d-block">Enable for low VRAM systems (slower but uses less GPU memory)</small>
                        </div>
                    </div>
                </div>
                
                <!-- FLUX/UltraFlux Options -->
                <div class="row mb-3" id="flux-options" style="display: none;">
                    <div class="col-md-12">
                        <label for="max-sequence-length" class="form-label">Max Sequence Length</label>
                        <input type="number" class="form-control" id="max-sequence-length" min="128" max="1024" value="512" step="64">
                        <small class="text-muted">Maximum token length for prompt (128-1024). Higher values allow longer prompts but use more memory.</small>
                    </div>
                </div>
                
                <!-- Qwen-Image Options -->
                <div class="row mb-3" id="qwen-options" style="display: none;">
                    <div class="col-md-12">
                        <label for="true-cfg-scale" class="form-label">True CFG Scale</label>
                        <input type="number" class="form-control" id="true-cfg-scale" min="1.0" max="20.0" value="4.0" step="0.5">
                        <small class="text-muted">CFG scale parameter for Qwen-Image models (default: 4.0). Controls how closely the model follows the prompt.</small>
                    </div>
                </div>
                
                <button type="button" class="btn btn-primary" id="btn-generate" disabled>
                    <i class="bi bi-magic me-2"></i>Generate Image
                </button>
                
                <!-- Generation Progress -->
                <div id="generation-progress" class="mt-4" style="display: none;">
                    <h6>Generation Progress:</h6>
                    <div class="progress mb-2" style="height: 25px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                             id="generation-progress-bar" role="progressbar" style="width: 0%">0%</div>
                    </div>
                    <p class="text-muted small mb-0" id="generation-status">Preparing...</p>
                </div>
                
                <!-- Generated Image -->
                <div id="generated-image-container" class="mt-4" style="display: none;">
                    <h6>Generated Image:</h6>
                    <div class="text-center">
                        <img id="generated-image" src="" alt="Generated image" class="img-fluid rounded" style="max-height: 600px;">
                    </div>
                    <div class="mt-3 text-center">
                        <button class="btn btn-sm btn-outline-primary" id="btn-download-image">
                            <i class="bi bi-download me-1"></i>Download Image
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const btnGenerate = document.getElementById('btn-generate');
    const promptInput = document.getElementById('prompt-input');
    
    // Load available models
    loadModels();
    
    // Reload models when management dropdown changes
    const manageSelect = document.getElementById('model-select-manage');
    if (manageSelect) {
        manageSelect.addEventListener('change', function() {
            loadModels(); // Refresh both dropdowns
        });
    }
    
    // Show/hide SDXL/UltraFlux/Qwen options based on selected model
    const modelSelect = document.getElementById('model-select');
    const sdxlOptions = document.getElementById('sdxl-options');
    const ultrafluxOptions = document.getElementById('ultraflux-options');
    const qwenOptions = document.getElementById('qwen-options');
    function updateModelOptions() {
        const modelId = modelSelect.value.toLowerCase();
        const isSDXL = modelId.includes('xl') || modelId.includes('stable-diffusion-xl') || modelId.includes('animagine');
        const isUltraFlux = modelId.includes('ultraflux') || modelId.includes('ultra-flux');
        const isQwen = modelId.includes('qwen') && modelId.includes('image');
        
        if (sdxlOptions) {
            sdxlOptions.style.display = isSDXL ? 'block' : 'none';
        }
        if (ultrafluxOptions) {
            ultrafluxOptions.style.display = isUltraFlux ? 'block' : 'none';
        }
        if (qwenOptions) {
            qwenOptions.style.display = isQwen ? 'block' : 'none';
        }
    }
    modelSelect.addEventListener('change', updateModelOptions);
    
    // Enable generate button when prompt is entered
    promptInput.addEventListener('input', function() {
        btnGenerate.disabled = !this.value.trim();
    });
    
    btnGenerate.addEventListener('click', generateImage);
    document.getElementById('btn-download-image')?.addEventListener('click', downloadImage);
});

async function loadModels() {
    try {
        const response = await fetch('/ai-services/api/text_to_image/models');
        const data = await response.json();
        
        if (data.success) {
            const select = document.getElementById('model-select');
            if (select) {
                if (data.models.length === 0) {
                    // No models downloaded
                    select.innerHTML = '<option value="">No models downloaded. Please download a model first.</option>';
                    select.disabled = true;
                    const btnGenerate = document.getElementById('btn-generate');
                    if (btnGenerate) btnGenerate.disabled = true;
                } else {
                    select.disabled = false;
                    select.innerHTML = data.models.map(model => 
                        `<option value="${model.id}" ${model.selected ? 'selected' : ''}>
                            ${model.name}${model.selected ? ' (Active)' : ''}${model.size_gb ? ` (${model.size_gb.toFixed(2)} GB)` : ''}
                        </option>`
                    ).join('');
                
                    // Update SDXL/FLUX/Qwen options visibility after loading models
                    const sdxlOptions = document.getElementById('sdxl-options');
                    const fluxOptions = document.getElementById('flux-options');
                    const qwenOptions = document.getElementById('qwen-options');
                    if (sdxlOptions || fluxOptions || qwenOptions) {
                        const selectedModelId = select.value.toLowerCase();
                        const isSDXL = selectedModelId.includes('xl') || selectedModelId.includes('stable-diffusion-xl') || selectedModelId.includes('animagine');
                        const isFlux = (selectedModelId.includes('flux') && !selectedModelId.includes('ultraflux') && !selectedModelId.includes('ultra-flux')) || selectedModelId.includes('black-forest-labs');
                        const isQwen = selectedModelId.includes('qwen') && selectedModelId.includes('image');
                        
                        if (sdxlOptions) {
                            sdxlOptions.style.display = isSDXL ? 'block' : 'none';
                        }
                        if (fluxOptions) {
                            fluxOptions.style.display = isFlux ? 'block' : 'none';
                        }
                        if (qwenOptions) {
                            qwenOptions.style.display = isQwen ? 'block' : 'none';
                        }
                    }
                }
            }
            
            // Also update the management dropdown if it exists
            const manageSelect = document.getElementById('model-select-manage');
            if (manageSelect) {
                if (data.models.length === 0) {
                    manageSelect.innerHTML = '<option value="">No models downloaded</option>';
                } else {
                    manageSelect.innerHTML = '<option value="">-- Select Model --</option>';
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name}${model.selected ? ' (Active)' : ''}`;
                        if (model.selected) option.selected = true;
                        manageSelect.appendChild(option);
                    });
                }
            }
        }
    } catch (error) {
        console.error('Failed to load models:', error);
    }
}

function generateImage() {
    const prompt = document.getElementById('prompt-input').value.trim();
    const modelId = document.getElementById('model-select').value;
    
    if (!prompt) {
        alert('Please enter a text prompt');
        return;
    }
    
    const negativePrompt = document.getElementById('negative-prompt').value.trim();
    const imageSize = document.getElementById('image-size').value;
    const numSteps = parseInt(document.getElementById('num-steps').value) || 50;
    const guidanceScale = parseFloat(document.getElementById('guidance-scale').value) || 7.5;
    const useRefiner = document.getElementById('use-refiner')?.checked || false;
    const useCpuOffload = document.getElementById('use-cpu-offload')?.checked || false;
    const maxSequenceLength = parseInt(document.getElementById('max-sequence-length')?.value) || 512;
    const trueCfgScale = parseFloat(document.getElementById('true-cfg-scale')?.value) || null;
    
    // Show progress
    const progressDiv = document.getElementById('generation-progress');
    const progressBar = document.getElementById('generation-progress-bar');
    const statusText = document.getElementById('generation-status');
    const btnGenerate = document.getElementById('btn-generate');
    
    progressDiv.style.display = 'block';
    progressBar.style.width = '10%';
    statusText.textContent = 'Sending request...';
    btnGenerate.disabled = true;
    
    // Call API - now returns task_id for async generation
    fetch('/ai-services/api/text-to-image/generate', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            model_id: modelId,
            prompt: prompt,
            negative_prompt: negativePrompt,
            image_size: imageSize,
            num_steps: numSteps,
            guidance_scale: guidanceScale,
            use_refiner: useRefiner,
            use_cpu_offload: useCpuOffload,
            max_sequence_length: maxSequenceLength,
            true_cfg_scale: trueCfgScale
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.task_id) {
            // Poll task status
            pollGenerationStatus(data.task_id);
        } else if (data.success && data.image) {
            // Direct result (backward compatibility)
            progressBar.style.width = '100%';
            statusText.textContent = 'Generation complete!';
            displayGeneratedImage(data.image);
            btnGenerate.disabled = false;
        } else {
            progressBar.style.width = '100%';
            statusText.textContent = 'Generation failed: ' + (data.error || 'Unknown error');
            statusText.classList.add('text-danger');
            btnGenerate.disabled = false;
            alert('Failed to start generation: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        progressBar.style.width = '100%';
        statusText.textContent = 'Error: ' + error.message;
        statusText.classList.add('text-danger');
        btnGenerate.disabled = false;
        alert('Error generating image: ' + error.message);
    });
}

function pollGenerationStatus(taskId) {
    const progressBar = document.getElementById('generation-progress-bar');
    const statusText = document.getElementById('generation-status');
    const btnGenerate = document.getElementById('btn-generate');
    
    let pollCount = 0;
    const maxPolls = 300; // 10 minutes max (300 * 2 seconds)
    
    const poll = setInterval(() => {
        pollCount++;
        
        fetch(`/tasks/${taskId}/status`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Update progress
                if (data.progress !== undefined && progressBar) {
                    progressBar.style.width = data.progress + '%';
                    progressBar.textContent = Math.round(data.progress) + '%';
                }
                
                if (data.current_step && statusText) {
                    statusText.textContent = data.current_step;
                }
                
                if (data.status === 'completed') {
                    clearInterval(poll);
                    progressBar.style.width = '100%';
                    statusText.textContent = 'Generation complete!';
                    
                    // Get result
                    if (data.result && data.result.image) {
                        displayGeneratedImage(data.result.image);
                    } else {
                        alert('Generation completed but no image received');
                    }
                    
                    btnGenerate.disabled = false;
                } else if (data.status === 'failed') {
                    clearInterval(poll);
                    progressBar.style.width = '100%';
                    statusText.textContent = 'Generation failed: ' + (data.error || 'Unknown error');
                    statusText.classList.add('text-danger');
                    btnGenerate.disabled = false;
                    alert('Generation failed: ' + (data.error || 'Unknown error'));
                }
                
                // Timeout check
                if (pollCount >= maxPolls) {
                    clearInterval(poll);
                    progressBar.style.width = '100%';
                    statusText.textContent = 'Generation timeout - taking longer than expected';
                    statusText.classList.add('text-warning');
                    btnGenerate.disabled = false;
                    alert('Generation is taking longer than expected. Please check if the model is still downloading or try again.');
                }
            })
            .catch(error => {
                console.error('Polling error:', error);
                if (pollCount > 10) {
                    clearInterval(poll);
                    statusText.textContent = 'Error checking status: ' + error.message;
                    statusText.classList.add('text-danger');
                    btnGenerate.disabled = false;
                }
            });
    }, 2000); // Poll every 2 seconds
}

function displayGeneratedImage(imageBase64) {
    document.getElementById('generated-image').src = 'data:image/png;base64,' + imageBase64;
    document.getElementById('generated-image-container').style.display = 'block';
    document.getElementById('generated-image').dataset.imageData = imageBase64;
}

function downloadImage() {
    const img = document.getElementById('generated-image');
    const imageData = img.dataset.imageData;
    
    if (!imageData) {
        alert('No image to download');
        return;
    }
    
    // Convert base64 to blob
    const byteCharacters = atob(imageData);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: 'image/png' });
    
    const link = document.createElement('a');
    link.download = 'generated-image.png';
    link.href = URL.createObjectURL(blob);
    link.click();
    URL.revokeObjectURL(link.href);
}
</script>
{% endblock %}
